<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Image Localizator</title>
  <link rel="stylesheet" href="styles.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
</head>
<body>
  <header>
    <div class="header-bar">
      <div class="title-block">
        <h1>Image Localizator</h1>
        <p>Carica un'immagine, abbina punti tra foto e mappa OpenStreetMap in 3D (OSM Buildings), poi calcola la posa approssimata della fotocamera con il modello DLT.</p>
      </div>
      <div class="options-block">
        <button class="options-trigger" id="themeButton" aria-haspopup="true" aria-expanded="false">
          Tema <span class="options-trigger__chevron" aria-hidden="true"></span>
        </button>
        <div class="theme-panel" id="themePanel" role="dialog" aria-labelledby="themePanelTitle" hidden>
          <div class="theme-panel__section theme-panel__header">
            <div>
              <h3 id="themePanelTitle">Personalizza tema</h3>
              <p>Scegli uno stile oppure crea una nuova combinazione di colori.</p>
            </div>
            <button type="button" class="theme-panel__close" id="themeClose" aria-label="Chiudi menu temi">&times;</button>
          </div>
          <div class="theme-panel__section">
            <h4>Temi predefiniti</h4>
            <div class="theme-chip-list" id="themePresetList"></div>
          </div>
          <div class="theme-panel__section">
            <div class="theme-panel__section-header">
              <h4>Temi personali</h4>
              <button type="button" class="text-button" id="clearCustomThemes" hidden>Elimina tutti</button>
            </div>
            <div class="theme-chip-list" id="customThemeList" data-empty-message="Nessun tema salvato." data-empty="true"></div>
          </div>
          <div class="theme-panel__section">
            <h4>Crea nuovo tema</h4>
            <form id="customThemeForm">
              <label class="theme-field">
                <span>Nome tema</span>
                <input type="text" id="customThemeName" maxlength="32" placeholder="Es. Tramonto urbano" required />
              </label>
              <div class="theme-field-grid" id="customThemeFields"></div>
              <div class="theme-form-actions">
                <button type="submit" class="btn-primary">Salva tema</button>
              </div>
            </form>
          </div>
        </div>
      </div>
    </div>
  </header>

  <main>
    <section class="status-banner" id="statusBanner">
      <strong>Pronto:</strong>
      <span id="statusMessage">carica un'immagine per iniziare a creare corrispondenze 2D ? 3D.</span>
    </section>

    <section class="panels">
      <div class="panel image-panel">
        <h2>Foto di riferimento <span>(2D)</span></h2>
        <div class="upload-area">
          <label for="imageInput">Carica immagine...</label>
          <input type="file" id="imageInput" accept="image/*" />
          <div class="notice">Clicca sulla foto per aggiungere punti distintivi da collegare alla mappa.</div>
        </div>
        <div class="legend">
          <span><span class="dot image"></span> Punto collegato</span>
          <span><span class="dot pending"></span> In attesa del punto mappa</span>
        </div>
        <div class="image-container" id="imageWrapper">
          <img id="photo" alt="Foto di riferimento" />
          <canvas id="photoOverlay"></canvas>
          <div class="placeholder" id="photoPlaceholder">Carica un'immagine dell'area da localizzare. Clicca sulla foto per iniziare.</div>
        </div>
        <div class="controls-row">
          <button id="clearImagePoints">Cancella punti foto</button>
          <button id="fitImage">Adatta immagine</button>
        </div>
      </div>

      <div class="panel map-panel">
        <h2>Mappa OpenStreetMap <span>(3D OSM Buildings)</span></h2>
        <div class="map-container">
          <div id="map"></div>
        </div>
        <div class="notice">Clicca sulla mappa per posizionare il punto corrispondente. I marker sono trascinabili.</div>
        <div class="controls-row">
          <button id="zoomIn">Zoom +</button>
          <button id="zoomOut">Zoom -</button>
          <button id="tiltUp">Tilt +</button>
          <button id="tiltDown">Tilt -</button>
          <button id="rotateLeft">Ruota &larr;</button>
          <button id="rotateRight">Ruota &rarr;</button>
          <button id="resetView">Reset vista</button>
        </div>
      </div>
    </section>

    <section class="data-panel">
      <h2>Associazioni 2D ? 3D</h2>
      <div class="empty-state" id="emptyState">Servono almeno 6 corrispondenze complete per stimare la posa.</div>
      <table id="matchesTable" style="display:none;">
        <thead>
          <tr>
            <th>#</th>
            <th>Punto foto (px)</th>
            <th>Coord. mappa</th>
            <th>Altitudine (m)</th>
            <th>Azioni</th>
          </tr>
        </thead>
        <tbody id="matchesBody"></tbody>
      </table>
      <button class="btn-primary" id="solveButton">Calcola posa fotocamera</button>
      <div class="results-card" id="resultsCard" style="display:none;">
        <h3>Risultati stimati</h3>
        <div class="results-grid">
          <div class="metric"><span>Latitudine</span><strong id="resultLat">-</strong></div>
          <div class="metric"><span>Longitudine</span><strong id="resultLng">-</strong></div>
          <div class="metric"><span>Altitudine</span><strong id="resultAlt">-</strong></div>
          <div class="metric"><span>Heading</span><strong id="resultHeading">-</strong></div>
          <div class="metric"><span>Tilt</span><strong id="resultTilt">-</strong></div>
          <div class="metric"><span>Errore medio</span><strong id="resultReproj">-</strong></div>
        </div>
      </div>
    </section>
  </main>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/osmbuildings@latest/dist/OSMBuildings-Leaflet.js" crossorigin="" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/ml-matrix@6.10.4/matrix.umd.js" defer></script>
  <script defer>
    const ImageLocalizatorApp = (() => {
      'use strict';
      const THEME_VARIABLES = [
        { key: '--bg', label: 'Sfondo principale', defaultValue: '#050c1e' },
        { key: '--panel', label: 'Pannelli', defaultValue: '#111c3a' },
        { key: '--panel-2', label: 'Sfondo secondario', defaultValue: '#0f1a34' },
        { key: '--accent', label: 'Accento', defaultValue: '#38bdf8' },
        { key: '--text', label: 'Testo principale', defaultValue: '#f8fafc' },
        { key: '--muted', label: 'Testo secondario', defaultValue: '#b0c4ff' },
        { key: '--border', label: 'Bordi', defaultValue: '#24345a' },
        { key: '--danger', label: 'Avvisi', defaultValue: '#f43f5e' }
      ];
      const THEME_PRESETS = {
        aurora: {
          label: 'Aurora',
          values: {
            '--bg': '#050c1e',
            '--panel': '#111c3a',
            '--panel-2': '#0f1a34',
            '--accent': '#38bdf8',
            '--text': '#f8fafc',
            '--muted': '#b0c4ff',
            '--border': '#24345a',
            '--danger': '#f43f5e'
          }
        },
        dusk: {
          label: 'Tramonto',
          values: {
            '--bg': '#1a1035',
            '--panel': '#211347',
            '--panel-2': '#2c1a5a',
            '--accent': '#ff9f43',
            '--text': '#fdf2f8',
            '--muted': '#f5c8ff',
            '--border': '#412060',
            '--danger': '#f87171'
          }
        },
        forest: {
          label: 'Foresta',
          values: {
            '--bg': '#0b1c17',
            '--panel': '#142822',
            '--panel-2': '#1c3a31',
            '--accent': '#34d399',
            '--text': '#ecfdf5',
            '--muted': '#a7f3d0',
            '--border': '#1f4b3c',
            '--danger': '#f8b4b4'
          }
        },
        graphite: {
          label: 'Grafite',
          values: {
            '--bg': '#0b0d10',
            '--panel': '#14171c',
            '--panel-2': '#1c2128',
            '--accent': '#3b82f6',
            '--text': '#f3f4f6',
            '--muted': '#9ca3af',
            '--border': '#272b33',
            '--danger': '#f87272'
          }
        }
      };
      const STORAGE_KEYS = {
        activeTheme: 'imageLocalizator.theme.active',
        customThemes: 'imageLocalizator.theme.custom'
      };
      const state = {
        correspondences: [],
        nextId: 1,
        pending: null,
        image: {
          element: null,
          overlay: null,
          ctx: null,
          naturalWidth: 0,
          naturalHeight: 0
        },
        map: {
          instance: null,
          markers: null,
          osmb: null,
          defaultView: { center: [48.85837, 2.29448], zoom: 18 },
          view: { tilt: 45, rotation: 0 }
        },
        theme: {
          active: 'aurora',
          custom: {}
        },
        config: {
          storageAvailable: false
        }
      };
      const dom = {};
      function cacheDom() {
        dom.imageInput = document.getElementById('imageInput');
        dom.imageWrapper = document.getElementById('imageWrapper');
        dom.photo = document.getElementById('photo');
        dom.overlay = document.getElementById('photoOverlay');
        dom.placeholder = document.getElementById('photoPlaceholder');
        dom.clear = document.getElementById('clearImagePoints');
        dom.fit = document.getElementById('fitImage');
        dom.statusBanner = document.getElementById('statusBanner');
        dom.statusMessage = document.getElementById('statusMessage');
        dom.matchesTable = document.getElementById('matchesTable');
        dom.matchesBody = document.getElementById('matchesBody');
        dom.emptyState = document.getElementById('emptyState');
        dom.solve = document.getElementById('solveButton');
        dom.resultsCard = document.getElementById('resultsCard');
        dom.resultLat = document.getElementById('resultLat');
        dom.resultLng = document.getElementById('resultLng');
        dom.resultAlt = document.getElementById('resultAlt');
        dom.resultHeading = document.getElementById('resultHeading');
        dom.resultTilt = document.getElementById('resultTilt');
        dom.resultReproj = document.getElementById('resultReproj');
        dom.zoomIn = document.getElementById('zoomIn');
        dom.zoomOut = document.getElementById('zoomOut');
        dom.tiltUp = document.getElementById('tiltUp');
        dom.tiltDown = document.getElementById('tiltDown');
        dom.rotateLeft = document.getElementById('rotateLeft');
        dom.rotateRight = document.getElementById('rotateRight');
        dom.resetView = document.getElementById('resetView');
        dom.themeButton = document.getElementById('themeButton');
        dom.themePanel = document.getElementById('themePanel');
        dom.themeClose = document.getElementById('themeClose');
        dom.themePresetList = document.getElementById('themePresetList');
        dom.customThemeList = document.getElementById('customThemeList');
        dom.customThemeForm = document.getElementById('customThemeForm');
        dom.customThemeFields = document.getElementById('customThemeFields');
        dom.customThemeName = document.getElementById('customThemeName');
        dom.clearCustomThemes = document.getElementById('clearCustomThemes');
      }
      function safeAddEventListener(element, eventName, handler) {
        if (element && typeof element.addEventListener === 'function') {
          element.addEventListener(eventName, handler);
        }
      }
      function init() {
        if (!window.mlMatrix || !window.L) {
          alert('Librerie necessarie non disponibili.');
          return;
        }
        cacheDom();
        initializeStorage();
        initializeThemeManager();
        state.image.element = dom.photo;
        state.image.overlay = dom.overlay;
        state.image.ctx = dom.overlay.getContext('2d');
        safeAddEventListener(dom.imageInput, 'change', handleImageSelection);
        safeAddEventListener(dom.imageWrapper, 'click', handleImageClick);
        safeAddEventListener(dom.clear, 'click', () => clearPoints());
        safeAddEventListener(dom.fit, 'click', () => fitImage(true));
        safeAddEventListener(dom.matchesBody, 'click', handleTableClick);
        safeAddEventListener(dom.matchesBody, 'input', handleTableChange);
        safeAddEventListener(dom.solve, 'click', computePose);
        safeAddEventListener(dom.zoomIn, 'click', () => adjustZoom(1));
        safeAddEventListener(dom.zoomOut, 'click', () => adjustZoom(-1));
        safeAddEventListener(dom.tiltUp, 'click', () => adjustTilt(5));
        safeAddEventListener(dom.tiltDown, 'click', () => adjustTilt(-5));
        safeAddEventListener(dom.rotateLeft, 'click', () => adjustRotation(-10));
        safeAddEventListener(dom.rotateRight, 'click', () => adjustRotation(10));
        safeAddEventListener(dom.resetView, 'click', resetView);
        window.addEventListener('resize', syncOverlaySize);
        if (state.image.element) {
          state.image.element.addEventListener('load', () => {
            state.image.naturalWidth = state.image.element.naturalWidth;
            state.image.naturalHeight = state.image.element.naturalHeight;
            dom.placeholder.style.display = 'none';
            state.image.element.style.display = 'block';
            syncOverlaySize();
            drawOverlay();
            pushStatus('Immagine caricata. Seleziona un punto.', false);
          });
        }
        initMap();
      }
      function initializeStorage() {
        try {
          const testKey = '__image_localizator__';
          localStorage.setItem(testKey, '1');
          localStorage.removeItem(testKey);
          state.config.storageAvailable = true;
        } catch (error) {
          state.config.storageAvailable = false;
        }
      }
      function initMap() {
        state.map.instance = L.map('map', { zoomControl: false })
          .setView(state.map.defaultView.center, state.map.defaultView.zoom);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 20,
          attribution: '&copy; OpenStreetMap contributors'
        }).addTo(state.map.instance);
        L.control.zoom({ position: 'bottomright' }).addTo(state.map.instance);
        state.map.markers = L.layerGroup().addTo(state.map.instance);
        if (window.OSMBuildings) {
          state.map.osmb = new OSMBuildings(state.map.instance);
          state.map.osmb.setTilt(state.map.view.tilt);
          state.map.osmb.setRotation(state.map.view.rotation);
          state.map.osmb.load();
        }
        state.map.instance.on('click', (event) => {
          if (event.latlng) handleMapClick(event.latlng);
        });
        pushStatus('Mappa OSM pronta. Clicca sulla foto, poi sulla mappa.', false);
      }
      function handleImageSelection(event) {
        const file = event.target.files?.[0];
        if (!file) return;
        state.image.element.src = URL.createObjectURL(file);
        clearPoints(true);
        dom.resultsCard.style.display = 'none';
      }
      function handleImageClick(event) {
        if (!state.image.naturalWidth) return;
        const rect = state.image.element.getBoundingClientRect();
        if (event.clientX < rect.left || event.clientX > rect.right || event.clientY < rect.top || event.clientY > rect.bottom) return;
        const relativeX = (event.clientX - rect.left) / rect.width;
        const relativeY = (event.clientY - rect.top) / rect.height;
        const x = relativeX * state.image.naturalWidth;
        const y = relativeY * state.image.naturalHeight;
        const id = state.nextId++;
        const entry = { id, imagePoint: { x, y }, mapPoint: null, marker: null };
        state.correspondences.push(entry);
        state.pending = { id };
        updateTable();
        drawOverlay();
        highlightPending(id);
        pushStatus(`Punto #${id} aggiunto. Ora selezionalo sulla mappa.`, false);
      }
      function handleMapClick(latlng) {
        if (!state.pending) {
          pushStatus('Seleziona prima un punto sulla foto.', true);
          return;
        }
        const entry = state.correspondences.find((item) => item.id === state.pending.id);
        if (!entry) {
          state.pending = null;
          return;
        }
        if (entry.marker) {
          state.map.markers.removeLayer(entry.marker);
        }
        const altitude = entry.mapPoint?.altitude ?? 0;
        entry.mapPoint = {
          lat: latlng.lat,
          lng: latlng.lng,
          altitude,
          ecef: latLngAltToECEF(latlng.lat, latlng.lng, altitude)
        };
        entry.marker = L.marker(latlng, { draggable: true }).addTo(state.map.markers);
        entry.marker.bindTooltip(`#${entry.id}`, { permanent: true, direction: 'top', offset: [0, -12] });
        entry.marker.on('dragend', (event) => {
          const position = event.target.getLatLng();
          entry.mapPoint.lat = position.lat;
          entry.mapPoint.lng = position.lng;
          entry.mapPoint.ecef = latLngAltToECEF(position.lat, position.lng, entry.mapPoint.altitude ?? 0);
          updateTable();
        });
        state.pending = null;
        updateTable();
        drawOverlay();
        pushStatus(`Punto #${entry.id} collegato.`, false);
      }
      function clearPoints(skipStatus = false) {
        state.correspondences.forEach((entry) => {
          if (entry.marker) state.map.markers.removeLayer(entry.marker);
        });
        state.correspondences = [];
        state.pending = null;
        state.nextId = 1;
        updateTable();
        drawOverlay();
        dom.resultsCard.style.display = 'none';
        if (!skipStatus) {
          pushStatus('Punti rimossi.', false);
        }
      }
      function fitImage(notify) {
        if (!state.image.naturalWidth) return;
        state.image.element.style.width = '100%';
        state.image.element.style.height = 'auto';
        syncOverlaySize();
        if (notify) pushStatus('Immagine adattata al contenitore.', false);
      }
      function syncOverlaySize() {
        if (!state.image.naturalWidth) return;
        const rect = state.image.element.getBoundingClientRect();
        state.image.overlay.width = rect.width;
        state.image.overlay.height = rect.height;
        state.image.overlay.style.width = `${rect.width}px`;
        state.image.overlay.style.height = `${rect.height}px`;
        drawOverlay();
      }
      function drawOverlay() {
        const ctx = state.image.ctx;
        if (!ctx) return;
        ctx.clearRect(0, 0, state.image.overlay.width, state.image.overlay.height);
        ctx.lineWidth = 2;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        state.correspondences.forEach((entry) => {
          if (!entry.imagePoint) return;
          const { x, y } = toDisplay(entry.imagePoint);
          const pending = state.pending?.id === entry.id;
          ctx.fillStyle = pending ? '#f97316' : '#38bdf8';
          ctx.strokeStyle = 'rgba(0,0,0,0.4)';
          ctx.beginPath();
          ctx.arc(x, y, 7, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = '#04122e';
          ctx.font = '600 11px "Segoe UI"';
          ctx.fillText(entry.id, x, y + 0.5);
        });
      }
      function toDisplay(point) {
        const rect = state.image.element.getBoundingClientRect();
        return {
          x: point.x * (rect.width / state.image.naturalWidth),
          y: point.y * (rect.height / state.image.naturalHeight)
        };
      }
      function updateTable() {
        dom.matchesBody.innerHTML = '';
        if (!state.correspondences.length) {
          dom.matchesTable.style.display = 'none';
          dom.emptyState.style.display = 'block';
          return;
        }
        dom.matchesTable.style.display = 'table';
        dom.emptyState.style.display = 'none';
        state.correspondences.forEach((entry) => {
          const tr = document.createElement('tr');
          tr.dataset.id = entry.id.toString();
          const coords = entry.mapPoint
            ? `<div>Lat: ${entry.mapPoint.lat.toFixed(6)}</div><div>Lng: ${entry.mapPoint.lng.toFixed(6)}</div>`
            : '<div class="secondary">Clicca sulla mappa</div>';
          const altitude = entry.mapPoint?.altitude ?? '';
          tr.innerHTML = `
            <td><span class="badge">${entry.id}</span></td>
            <td>${entry.imagePoint.x.toFixed(1)}, ${entry.imagePoint.y.toFixed(1)}</td>
            <td>${coords}</td>
            <td><input type="number" class="altitude-input" data-id="${entry.id}" value="${altitude}" step="0.1" placeholder="Alt"></td>
            <td><button data-action="remove" data-id="${entry.id}">Rimuovi</button></td>
          `;
          dom.matchesBody.appendChild(tr);
        });
        if (state.pending) highlightPending(state.pending.id);
      }
      function highlightPending(id) {
        dom.matchesBody.querySelectorAll('tr').forEach((row) => {
          row.style.background = Number(row.dataset.id) === id ? 'rgba(249,115,22,0.18)' : '';
        });
      }
      function handleTableClick(event) {
        const target = event.target;
        if (!(target instanceof HTMLElement)) return;
        if (target.dataset.action === 'remove') {
          removeCorrespondence(Number(target.dataset.id));
        }
      }
      function handleTableChange(event) {
        const target = event.target;
        if (!(target instanceof HTMLInputElement)) return;
        if (!target.classList.contains('altitude-input')) return;
        const id = Number(target.dataset.id);
        const value = Number(target.value);
        if (Number.isNaN(value)) return;
        const entry = state.correspondences.find((item) => item.id === id);
        if (entry && entry.mapPoint) {
          entry.mapPoint.altitude = value;
          entry.mapPoint.ecef = latLngAltToECEF(entry.mapPoint.lat, entry.mapPoint.lng, value);
        }
      }
      function removeCorrespondence(id) {
        const index = state.correspondences.findIndex((entry) => entry.id === id);
        if (index === -1) return;
        const [removed] = state.correspondences.splice(index, 1);
        if (removed?.marker) {
          state.map.markers.removeLayer(removed.marker);
        }
        if (state.pending?.id === id) {
          state.pending = null;
        }
        updateTable();
        drawOverlay();
        pushStatus(`Corrispondenza #${id} rimossa.`, false);
      }
      function pushStatus(message, isError) {
        dom.statusBanner.style.background = isError ? 'rgba(244,63,94,0.18)' : 'rgba(56,189,248,0.12)';
        dom.statusBanner.style.borderColor = isError ? 'rgba(244,63,94,0.4)' : 'rgba(56,189,248,0.4)';
        dom.statusMessage.textContent = message;
      }
      function adjustZoom(delta) {
        if (!state.map.instance) return;
        state.map.instance.setZoom(state.map.instance.getZoom() + delta);
      }

      function adjustTilt(delta) {
        if (!state.map.osmb) return;
        state.map.view.tilt = Math.max(0, Math.min(60, state.map.view.tilt + delta));
        state.map.osmb.setTilt(state.map.view.tilt);
      }

      function adjustRotation(delta) {
        if (!state.map.osmb) return;
        state.map.view.rotation = (state.map.view.rotation + delta + 360) % 360;
        state.map.osmb.setRotation(state.map.view.rotation);
      }

      function resetView() {
        if (!state.map.instance) return;
        state.map.instance.setView(state.map.defaultView.center, state.map.defaultView.zoom);
        if (state.map.osmb) {
          state.map.view.tilt = 45;
          state.map.view.rotation = 0;
          state.map.osmb.setTilt(state.map.view.tilt);
          state.map.osmb.setRotation(state.map.view.rotation);
        }
      }

      function initializeThemeManager() {
        if (!dom.themeButton || !dom.themePanel) {
          return;
        }
        buildCustomThemeFields();
        if (state.config.storageAvailable) {
          state.theme.custom = loadCustomThemes();
          const storedActive = localStorage.getItem(STORAGE_KEYS.activeTheme);
          if (storedActive && (THEME_PRESETS[storedActive] || state.theme.custom[storedActive])) {
            state.theme.active = storedActive;
          }
        }
        applyTheme(state.theme.active);
        renderThemeLists();
        safeAddEventListener(dom.themeButton, 'click', toggleThemePanel);
        safeAddEventListener(dom.themeClose, 'click', () => closeThemePanel(true));
        safeAddEventListener(dom.themePresetList, 'click', handleThemeChipClick);
        safeAddEventListener(dom.customThemeList, 'click', handleThemeChipClick);
        safeAddEventListener(dom.customThemeForm, 'submit', handleCustomThemeSubmit);
        safeAddEventListener(dom.clearCustomThemes, 'click', clearAllCustomThemes);
        document.addEventListener('click', handleThemeOutsideClick);
        document.addEventListener('keydown', (event) => {
          if (event.key === 'Escape') {
            closeThemePanel();
          }
        });
      }

      function buildCustomThemeFields() {
        if (!dom.customThemeFields) {
          return;
        }
        dom.customThemeFields.innerHTML = '';
        THEME_VARIABLES.forEach(({ key, label, defaultValue }) => {
          const wrapper = document.createElement('div');
          wrapper.className = 'theme-color-picker';
          const inputId = `theme-color-${key.replace(/^-+/, '')}`;
          wrapper.innerHTML = `
            <label for="${inputId}">${label}</label>
            <input type="color" id="${inputId}" data-variable="${key}" value="${defaultValue}">
          `;
          dom.customThemeFields.appendChild(wrapper);
        });
        populateCustomThemeFields();
      }

      function populateCustomThemeFields(values) {
        if (!dom.customThemeFields) {
          return;
        }
        const themeValues = values || getThemeDefinition(state.theme.active)?.values || {};
        THEME_VARIABLES.forEach(({ key, defaultValue }) => {
          const input = dom.customThemeFields.querySelector(`[data-variable="${key}"]`);
          if (!input) {
            return;
          }
          const value = themeValues[key] || defaultValue || '#000000';
          input.value = normalizeColor(value, defaultValue || '#000000');
        });
      }

      function renderThemeLists() {
        if (!dom.themePresetList || !dom.customThemeList) {
          return;
        }
        dom.themePresetList.innerHTML = '';
        Object.entries(THEME_PRESETS).forEach(([name, definition]) => {
          dom.themePresetList.appendChild(createThemeChip(name, definition, false));
        });
        dom.customThemeList.innerHTML = '';
        const customEntries = Object.entries(state.theme.custom);
        customEntries.forEach(([name, definition]) => {
          dom.customThemeList.appendChild(createThemeChip(name, definition, true));
        });
        const isEmpty = customEntries.length === 0;
        dom.customThemeList.dataset.empty = isEmpty ? 'true' : 'false';
        if (dom.clearCustomThemes) {
          dom.clearCustomThemes.hidden = isEmpty;
        }
      }

      function createThemeChip(name, definition, isCustom) {
        const wrapper = document.createElement('div');
        wrapper.className = 'theme-chip';
        wrapper.dataset.theme = name;
        wrapper.dataset.active = state.theme.active === name ? 'true' : 'false';
        const selectButton = document.createElement('button');
        selectButton.type = 'button';
        selectButton.className = 'theme-chip__select';
        selectButton.dataset.themeSelect = name;
        selectButton.textContent = definition.label || name;
        wrapper.appendChild(selectButton);
        if (isCustom) {
          const deleteButton = document.createElement('button');
          deleteButton.type = 'button';
          deleteButton.className = 'theme-chip__delete';
          deleteButton.dataset.themeDelete = name;
          deleteButton.setAttribute('aria-label', `Elimina il tema ${definition.label || name}`);
          deleteButton.textContent = 'Ã—';
          wrapper.appendChild(deleteButton);
        }
        return wrapper;
      }

      function handleThemeChipClick(event) {
        const deleteBtn = event.target.closest('[data-theme-delete]');
        if (deleteBtn) {
          const themeName = deleteBtn.dataset.themeDelete;
          delete state.theme.custom[themeName];
          saveCustomThemes();
          if (state.theme.active === themeName) {
            applyTheme('aurora');
          } else {
            renderThemeLists();
          }
          return;
        }
        const selectBtn = event.target.closest('[data-theme-select]');
        if (selectBtn) {
          applyTheme(selectBtn.dataset.themeSelect);
          closeThemePanel();
        }
      }

      function handleCustomThemeSubmit(event) {
        event.preventDefault();
        if (!dom.customThemeName) {
          return;
        }
        const label = dom.customThemeName.value.trim();
        if (!label) {
          dom.customThemeName.focus();
          return;
        }
        const themeValues = {};
        THEME_VARIABLES.forEach(({ key, defaultValue }) => {
          const input = dom.customThemeFields.querySelector(`[data-variable="${key}"]`);
          themeValues[key] = (input?.value || defaultValue).trim();
        });
        const themeId = generateThemeId(label);
        state.theme.custom[themeId] = { label, values: themeValues };
        saveCustomThemes();
        dom.customThemeForm.reset();
        populateCustomThemeFields(themeValues);
        renderThemeLists();
        applyTheme(themeId);
      }

      function clearAllCustomThemes() {
        if (!Object.keys(state.theme.custom).length) {
          return;
        }
        if (!confirm('Vuoi eliminare tutti i temi personalizzati?')) {
          return;
        }
        state.theme.custom = {};
        saveCustomThemes();
        renderThemeLists();
      }

      function toggleThemePanel() {
        setThemePanelVisibility(dom.themePanel?.hidden);
      }

      function closeThemePanel(focusButton = false) {
        setThemePanelVisibility(false, focusButton);
      }

      function setThemePanelVisibility(isVisible, focusButton = false) {
        if (!dom.themePanel || !dom.themeButton) {
          return;
        }
        if (isVisible) {
          dom.themePanel.hidden = false;
          dom.themePanel.classList.add('theme-panel--open');
          dom.themeButton.setAttribute('aria-expanded', 'true');
          populateCustomThemeFields();
        } else {
          dom.themePanel.hidden = true;
          dom.themePanel.classList.remove('theme-panel--open');
          dom.themeButton.setAttribute('aria-expanded', 'false');
          if (focusButton) {
            dom.themeButton.focus();
          }
        }
      }

      function handleThemeOutsideClick(event) {
        if (!dom.themePanel || dom.themePanel.hidden) {
          return;
        }
        const insidePanel = dom.themePanel.contains(event.target);
        const onButton = dom.themeButton?.contains(event.target);
        if (!insidePanel && !onButton) {
          closeThemePanel();
        }
      }

      function applyTheme(themeName) {
        const definition = getThemeDefinition(themeName);
        if (!definition) {
          return;
        }
        Object.entries(definition.values).forEach(([variable, value]) => {
          document.documentElement.style.setProperty(variable, value);
        });
        state.theme.active = themeName;
        if (state.config.storageAvailable) {
          localStorage.setItem(STORAGE_KEYS.activeTheme, themeName);
        }
        renderThemeLists();
        populateCustomThemeFields(definition.values);
      }

      function getThemeDefinition(name) {
        return THEME_PRESETS[name] || state.theme.custom[name] || null;
      }

      function saveCustomThemes() {
        if (!state.config.storageAvailable) {
          return;
        }
        localStorage.setItem(STORAGE_KEYS.customThemes, JSON.stringify(state.theme.custom));
      }

      function loadCustomThemes() {
        if (!state.config.storageAvailable) {
          return {};
        }
        try {
          const stored = localStorage.getItem(STORAGE_KEYS.customThemes);
          return stored ? JSON.parse(stored) : {};
        } catch (error) {
          return {};
        }
      }

      function normalizeColor(value, fallback) {
        const trimmed = (value || '').trim();
        if (trimmed.startsWith('#') && (trimmed.length === 7 || trimmed.length === 4)) {
          return trimmed.length === 4
            ? `#${trimmed[1]}${trimmed[1]}${trimmed[2]}${trimmed[2]}${trimmed[3]}${trimmed[3]}`
            : trimmed;
        }
        return fallback || '#000000';
      }

      function generateThemeId(label) {
        const base = label
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, '-')
          .replace(/^-+|-+$/g, '') || 'tema';
        let candidate = base;
        let counter = 1;
        while (THEME_PRESETS[candidate] || state.theme.custom[candidate]) {
          candidate = `${base}-${counter++}`;
        }
        return candidate;
      }
      function computePose() {
        if (!window.mlMatrix) {
          pushStatus('ml-matrix non disponibile: impossibile stimare la posa.', true);
          return;
        }
        const usable = state.correspondences.filter((entry) => entry.imagePoint && entry.mapPoint?.ecef);
        if (usable.length < 6) {
          pushStatus('Servono almeno 6 corrispondenze complete per stimare la posa.', true);
          return;
        }
        try {
          const { Matrix, SVD } = window.mlMatrix;
          const Adata = [];
          usable.forEach((entry) => {
            const { x, y } = entry.imagePoint;
            const { x: X, y: Y, z: Z } = entry.mapPoint.ecef;
            Adata.push([X, Y, Z, 1, 0, 0, 0, 0, -x * X, -x * Y, -x * Z, -x]);
            Adata.push([0, 0, 0, 0, X, Y, Z, 1, -y * X, -y * Y, -y * Z, -y]);
          });
          const A = new Matrix(Adata);
          const svd = new SVD(A);
          const V = svd.rightSingularVectors;
          const h = V.getColumn(V.columns - 1);
          const P = Matrix.from1DArray(3, 4, h);
          const M = P.subMatrix(0, 2, 0, 2);
          const p4 = P.subMatrix(0, 2, 3, 3);
          const Minv = invert3x3(M, Matrix);
          const c = Minv.mmul(p4);
          const cameraECEF = { x: -c.get(0, 0), y: -c.get(1, 0), z: -c.get(2, 0) };
          const geo = ecefToGeodetic(cameraECEF.x, cameraECEF.y, cameraECEF.z);
          dom.resultLat.textContent = `${geo.lat.toFixed(6)}?`;
          dom.resultLng.textContent = `${geo.lng.toFixed(6)}?`;
          dom.resultAlt.textContent = `${geo.altitude.toFixed(2)} m`;
          try {
            const { R } = decomposeKR(M, Matrix);
            const forward = cameraForwardVector(R);
            const { heading, tilt } = computeViewAngles(forward, cameraECEF);
            dom.resultHeading.textContent = `${heading.toFixed(1)}?`;
            dom.resultTilt.textContent = `${tilt.toFixed(1)}?`;
          } catch (orientationError) {
            dom.resultHeading.textContent = 'n/d';
            dom.resultTilt.textContent = 'n/d';
          }
          const reprojectionError = computeReprojectionError(P, usable);
          dom.resultReproj.textContent = `${reprojectionError.toFixed(2)} px`;
          dom.resultsCard.style.display = 'grid';
          pushStatus('Posa stimata. Verifica i risultati.', false);
        } catch (error) {
          console.error(error);
          pushStatus('Errore nel calcolo della posa.', true);
        }
      }
      function computeReprojectionError(P, correspondences) {
        const { Matrix } = window.mlMatrix;
        let total = 0;
        let count = 0;
        correspondences.forEach((entry) => {
          const world = entry.mapPoint.ecef;
          const point = Matrix.columnVector([world.x, world.y, world.z, 1]);
          const projected = P.mmul(point);
          const w = projected.get(2, 0);
          if (Math.abs(w) < 1e-9) return;
          const x = projected.get(0, 0) / w;
          const y = projected.get(1, 0) / w;
          total += Math.hypot(x - entry.imagePoint.x, y - entry.imagePoint.y);
          count += 1;
        });
        return count ? total / count : 0;
      }
      function decomposeKR(M, Matrix) {
        const J = new Matrix([
          [0, 0, 1],
          [0, 1, 0],
          [1, 0, 0]
        ]);
        const QR = new window.mlMatrix.QRDecomposition(J.mmul(M.transpose()));
        let R = QR.QR.transpose().mmul(J);
        let K = J.mmul(QR.R.transpose()).mmul(J);
        const diagSigns = [K.get(0, 0), K.get(1, 1), K.get(2, 2)].map((value) => (value < 0 ? -1 : 1));
        const signMatrix = Matrix.diag(diagSigns);
        K = K.mmul(signMatrix);
        R = signMatrix.mmul(R);
        const scale = K.get(2, 2);
        if (scale !== 0) {
          K = K.mul(1 / scale);
        }
        if (R.det() < 0) {
          R = R.mul(-1);
          K = K.mul(-1);
        }
        return { K, R };
      }
      function cameraForwardVector(R) {
        const Rt = R.transpose();
        const forward = {
          x: Rt.get(0, 2),
          y: Rt.get(1, 2),
          z: Rt.get(2, 2)
        };
        const norm = Math.sqrt(forward.x ** 2 + forward.y ** 2 + forward.z ** 2) || 1;
        return {
          x: forward.x / norm,
          y: forward.y / norm,
          z: forward.z / norm
        };
      }
      function computeViewAngles(forward, cameraECEF) {
        const geo = ecefToGeodetic(cameraECEF.x, cameraECEF.y, cameraECEF.z);
        const enu = ecefVectorToENU(forward, geo.lat, geo.lng);
        const heading = (Math.atan2(enu.east, enu.north) * 180 / Math.PI + 360) % 360;
        const horizontal = Math.sqrt(enu.east ** 2 + enu.north ** 2);
        const pitch = Math.atan2(enu.up, horizontal) * 180 / Math.PI;
        const tilt = Math.max(0, Math.min(90, 90 - pitch));
        return { heading, tilt };
      }
      function ecefVectorToENU(vector, latDeg, lonDeg) {
        const lat = degToRad(latDeg);
        const lon = degToRad(lonDeg);
        const sinLat = Math.sin(lat);
        const cosLat = Math.cos(lat);
        const sinLon = Math.sin(lon);
        const cosLon = Math.cos(lon);
        const east = -sinLon * vector.x + cosLon * vector.y;
        const north = -sinLat * cosLon * vector.x - sinLat * sinLon * vector.y + cosLat * vector.z;
        const up = cosLat * cosLon * vector.x + cosLat * sinLon * vector.y + sinLat * vector.z;
        return { east, north, up };
      }
      function latLngAltToECEF(latDeg, lonDeg, altitude) {
        const a = 6378137.0;
        const e2 = 6.69437999014e-3;
        const lat = degToRad(latDeg);
        const lon = degToRad(lonDeg);
        const cosLat = Math.cos(lat);
        const sinLat = Math.sin(lat);
        const cosLon = Math.cos(lon);
        const sinLon = Math.sin(lon);
        const N = a / Math.sqrt(1 - e2 * sinLat * sinLat);
        const x = (N + altitude) * cosLat * cosLon;
        const y = (N + altitude) * cosLat * sinLon;
        const z = (N * (1 - e2) + altitude) * sinLat;
        return { x, y, z };
      }
      function ecefToGeodetic(x, y, z) {
        const a = 6378137.0;
        const e2 = 6.69437999014e-3;
        const b = a * Math.sqrt(1 - e2);
        const ep2 = (a * a - b * b) / (b * b);
        const p = Math.sqrt(x * x + y * y);
        const theta = Math.atan2(z * a, p * b);
        const sinTheta = Math.sin(theta);
        const cosTheta = Math.cos(theta);
        const lat = Math.atan2(z + ep2 * b * sinTheta ** 3, p - e2 * a * cosTheta ** 3);
        const lon = Math.atan2(y, x);
        const sinLat = Math.sin(lat);
        const N = a / Math.sqrt(1 - e2 * sinLat * sinLat);
        const alt = p / Math.cos(lat) - N;
        return { lat: radToDeg(lat), lng: radToDeg(lon), altitude: alt };
      }
      function invert3x3(M, Matrix) {
        const m = M.to2DArray();
        const [[a, b, c], [d, e, f], [g, h, i]] = m;
        const det = a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);
        if (Math.abs(det) < 1e-9) throw new Error('Matrice non invertibile');
        const inv = [
          [(e * i - f * h) / det, (c * h - b * i) / det, (b * f - c * e) / det],
          [(f * g - d * i) / det, (a * i - c * g) / det, (c * d - a * f) / det],
          [(d * h - e * g) / det, (b * g - a * h) / det, (a * e - b * d) / det]
        ];
        return new Matrix(inv);
      }
      function degToRad(value) { return value * Math.PI / 180; }
      function radToDeg(value) { return value * 180 / Math.PI; }
      document.addEventListener('DOMContentLoaded', () => ImageLocalizatorApp.init());
      return { init };
    })();
  </script>
</body>
</html>
