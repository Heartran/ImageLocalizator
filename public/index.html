<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Image Localizator</title>
  <link rel="stylesheet" href="styles.css" />
  <link rel="stylesheet" href="https://unpkg.com/cesium@1.119.0/Build/Cesium/Widgets/widgets.css" crossorigin="" />
</head>
<body>
  <header>
    <div class="header-bar">
      <div class="title-block">
        <h1>Image Localizator</h1>
        <p>Carica un'immagine, abbina punti tra foto e una mappa 2D OpenStreetMap gestita da Cesium con edifici importabili, poi calcola la posa approssimata della fotocamera con il modello DLT.</p>
      </div>
      <div class="options-block">
        <button class="options-trigger" id="themeButton" aria-haspopup="true" aria-expanded="false">
          Tema <span class="options-trigger__chevron" aria-hidden="true"></span>
        </button>
        <div class="theme-panel" id="themePanel" role="dialog" aria-labelledby="themePanelTitle" hidden>
          <div class="theme-panel__section theme-panel__header">
            <div>
              <h3 id="themePanelTitle">Personalizza tema</h3>
              <p>Scegli uno stile oppure crea una nuova combinazione di colori.</p>
            </div>
            <button type="button" class="theme-panel__close" id="themeClose" aria-label="Chiudi menu temi">&times;</button>
          </div>
          <div class="theme-panel__section">
            <h4>Temi predefiniti</h4>
            <div class="theme-chip-list" id="themePresetList"></div>
          </div>
          <div class="theme-panel__section">
            <div class="theme-panel__section-header">
              <h4>Temi personali</h4>
              <button type="button" class="text-button" id="clearCustomThemes" hidden>Elimina tutti</button>
            </div>
            <div class="theme-chip-list" id="customThemeList" data-empty-message="Nessun tema salvato." data-empty="true"></div>
          </div>
          <div class="theme-panel__section">
            <h4>Crea nuovo tema</h4>
            <form id="customThemeForm">
              <label class="theme-field">
                <span>Nome tema</span>
                <input type="text" id="customThemeName" maxlength="32" placeholder="Es. Tramonto urbano" required />
              </label>
              <div class="theme-field-grid" id="customThemeFields"></div>
              <div class="theme-form-actions">
                <button type="submit" class="btn-primary">Salva tema</button>
              </div>
            </form>
          </div>
        </div>
      </div>
    </div>
  </header>

  <main>
    <section class="status-banner" id="statusBanner">
      <strong>Pronto:</strong>
      <span id="statusMessage">carica un'immagine per iniziare a creare corrispondenze 2D ? 3D.</span>
    </section>

    <section class="panels">
      <div class="panel image-panel">
        <h2>Foto di riferimento <span>(2D)</span></h2>
        <div class="upload-area">
          <label for="imageInput">Carica immagine...</label>
          <input type="file" id="imageInput" accept="image/*" />
          <div class="notice">Clicca sulla foto per aggiungere punti distintivi da collegare alla mappa.</div>
        </div>
        <div class="legend">
          <span><span class="dot image"></span> Punto collegato</span>
          <span><span class="dot pending"></span> In attesa del punto mappa</span>
        </div>
        <div class="image-container" id="imageWrapper">
          <img id="photo" alt="Foto di riferimento" />
          <canvas id="photoOverlay"></canvas>
          <div class="placeholder" id="photoPlaceholder">Carica un'immagine dell'area da localizzare. Clicca sulla foto per iniziare.</div>
        </div>
        <div class="controls-row">
          <button id="clearImagePoints">Cancella punti foto</button>
          <button id="fitImage">Adatta immagine</button>
        </div>
      </div>

      <div class="panel map-panel">
        <h2>Mappa OpenStreetMap 2D <span>(base Cesium)</span></h2>
        <div class="map-container">
          <div id="map"></div>
        </div>
        <div class="notice">Clicca sulla mappa 2D per posizionare il punto corrispondente. I marker sono trascinabili.</div>
        <div class="controls-row">
          <button id="zoomIn">Zoom +</button>
          <button id="zoomOut">Zoom -</button>
          <button id="resetView">Reset vista</button>
        </div>
        <div class="model-panel">
          <h3>Modelli 3D personalizzati</h3>
          <p>Importa file GLB/GLTF e posizionali sulla scena per sostituire gli edifici generici (es. modello dettagliato della Torre Eiffel).</p>
          <form id="modelForm" class="model-form">
            <div class="model-field">
              <label for="modelName">Nome modello</label>
              <input type="text" id="modelName" placeholder="Es. Torre Eiffel fotogrammetria" maxlength="64" required />
            </div>
            <div class="model-field">
              <label for="modelFile">File (.glb / .gltf)</label>
              <input type="file" id="modelFile" accept=".glb,.gltf,model/gltf-binary,model/gltf+json" required />
            </div>
            <div class="model-grid">
              <label>Latitudine<input type="number" id="modelLat" step="0.000001" required value="48.85837" /></label>
              <label>Longitudine<input type="number" id="modelLng" step="0.000001" required value="2.29448" /></label>
              <label>Altitudine (m)<input type="number" id="modelAlt" step="0.1" value="35" /></label>
              <label>Scala<input type="number" id="modelScale" step="0.1" value="1" min="0.01" /></label>
              <label>Heading<input type="number" id="modelHeading" step="1" value="0" /></label>
            </div>
            <div class="theme-form-actions">
              <button type="submit" class="btn-primary">Carica modello</button>
              <button type="button" id="clearModels">Rimuovi tutti</button>
            </div>
          </form>
          <div id="modelList" class="model-list" data-empty="true" data-empty-message="Nessun modello caricato."></div>
        </div>
      </div>

      <div class="panel ai-panel">
        <h2>Assistente IA Ollama</h2>
        <p class="ai-intro">Seleziona un modello Ollama locale e lascia che l'IA proponga automaticamente i punti corrispondenti sulla mappa 2D e una posa stimata.</p>
        <div class="ai-controls">
          <label class="ai-field">
            <span>Modello</span>
            <select id="aiModelSelect">
              <option value="" selected>Caricamento...</option>
            </select>
          </label>
          <button type="button" id="aiRefreshModels">Aggiorna elenco</button>
        </div>
        <button type="button" class="btn-primary" id="aiAutoButton">Auto-localizza con IA</button>
        <p class="ai-status" id="aiStatus" hidden></p>
        <pre id="aiReasoning" class="ai-reasoning" hidden></pre>
        <p class="ai-hint">Suggerimento: i modelli multimodali (es. <code>llava</code> o <code>llama3.2-vision</code>) funzionano meglio con immagini.</p>
      </div>
    </section>

    <section class="data-panel">
      <h2>Associazioni 2D ? 3D</h2>
      <div class="empty-state" id="emptyState">Servono almeno 6 corrispondenze complete per stimare la posa.</div>
      <table id="matchesTable" style="display:none;">
        <thead>
          <tr>
            <th>#</th>
            <th>Punto foto (px)</th>
            <th>Coord. mappa</th>
            <th>Altitudine (m)</th>
            <th>Azioni</th>
          </tr>
        </thead>
        <tbody id="matchesBody"></tbody>
      </table>
      <button class="btn-primary" id="solveButton">Calcola posa fotocamera</button>
      <div class="results-card" id="resultsCard" style="display:none;">
        <h3>Risultati stimati</h3>
        <div class="results-grid">
          <div class="metric"><span>Latitudine</span><strong id="resultLat">-</strong></div>
          <div class="metric"><span>Longitudine</span><strong id="resultLng">-</strong></div>
          <div class="metric"><span>Altitudine</span><strong id="resultAlt">-</strong></div>
          <div class="metric"><span>Heading</span><strong id="resultHeading">-</strong></div>
          <div class="metric"><span>Tilt</span><strong id="resultTilt">-</strong></div>
          <div class="metric"><span>Errore medio</span><strong id="resultReproj">-</strong></div>
        </div>
      </div>
    </section>
  </main>

  <script>
    window.CESIUM_BASE_URL = 'https://unpkg.com/cesium@1.119.0/Build/Cesium/';
  </script>
  <script src="https://unpkg.com/cesium@1.119.0/Build/Cesium/Cesium.js" crossorigin="" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/ml-matrix@6.10.4/matrix.umd.js" defer></script>
  <script defer>
    const ImageLocalizatorApp = (() => {
      'use strict';
      const LOGGING_CONFIG = {
        enabled: true,
        endpoint: '/api/log',
        useBeacon: true
      };
      window.LOGGING_CONFIG = LOGGING_CONFIG;
      const THEME_VARIABLES = [
        { key: '--bg', label: 'Sfondo principale', defaultValue: '#050c1e' },
        { key: '--panel', label: 'Pannelli', defaultValue: '#111c3a' },
        { key: '--panel-2', label: 'Sfondo secondario', defaultValue: '#0f1a34' },
        { key: '--accent', label: 'Accento', defaultValue: '#38bdf8' },
        { key: '--text', label: 'Testo principale', defaultValue: '#f8fafc' },
        { key: '--muted', label: 'Testo secondario', defaultValue: '#b0c4ff' },
        { key: '--border', label: 'Bordi', defaultValue: '#24345a' },
        { key: '--danger', label: 'Avvisi', defaultValue: '#f43f5e' }
      ];
      const THEME_PRESETS = {
        aurora: {
          label: 'Aurora',
          values: {
            '--bg': '#050c1e',
            '--panel': '#111c3a',
            '--panel-2': '#0f1a34',
            '--accent': '#38bdf8',
            '--text': '#f8fafc',
            '--muted': '#b0c4ff',
            '--border': '#24345a',
            '--danger': '#f43f5e'
          }
        },
        dusk: {
          label: 'Tramonto',
          values: {
            '--bg': '#1a1035',
            '--panel': '#211347',
            '--panel-2': '#2c1a5a',
            '--accent': '#ff9f43',
            '--text': '#fdf2f8',
            '--muted': '#f5c8ff',
            '--border': '#412060',
            '--danger': '#f87171'
          }
        },
        forest: {
          label: 'Foresta',
          values: {
            '--bg': '#0b1c17',
            '--panel': '#142822',
            '--panel-2': '#1c3a31',
            '--accent': '#34d399',
            '--text': '#ecfdf5',
            '--muted': '#a7f3d0',
            '--border': '#1f4b3c',
            '--danger': '#f8b4b4'
          }
        },
        graphite: {
          label: 'Grafite',
          values: {
            '--bg': '#0b0d10',
            '--panel': '#14171c',
            '--panel-2': '#1c2128',
            '--accent': '#3b82f6',
            '--text': '#f3f4f6',
            '--muted': '#9ca3af',
            '--border': '#272b33',
            '--danger': '#f87272'
          }
        }
      };
      const STORAGE_KEYS = {
        activeTheme: 'imageLocalizator.theme.active',
        customThemes: 'imageLocalizator.theme.custom'
      };
      const state = {
        correspondences: [],
        nextId: 1,
        pending: null,
        image: {
          element: null,
          overlay: null,
          ctx: null,
          naturalWidth: 0,
          naturalHeight: 0,
          localUrl: null,
          uploadInfo: null,
          uploadToken: 0
        },
        map: {
          viewer: null,
          handler: null,
          markers: new Map(),
          dragging: null,
          defaultView: { lat: 48.85837, lng: 2.29448, height: 550 },
          view: { pitch: -90, heading: 0 }
        },
        models: {
          entries: new Map(),
          nextId: 1
        },
        theme: {
          active: 'aurora',
          custom: {}
        },
        config: {
          storageAvailable: false
        },
        ai: {
          models: [],
          selectedModel: '',
          loadingModels: false,
          busy: false
        }
      };
      const dom = {};
      function cacheDom() {
        dom.imageInput = document.getElementById('imageInput');
        dom.imageWrapper = document.getElementById('imageWrapper');
        dom.photo = document.getElementById('photo');
        dom.overlay = document.getElementById('photoOverlay');
        dom.placeholder = document.getElementById('photoPlaceholder');
        dom.clear = document.getElementById('clearImagePoints');
        dom.fit = document.getElementById('fitImage');
        dom.statusBanner = document.getElementById('statusBanner');
        dom.statusMessage = document.getElementById('statusMessage');
        dom.matchesTable = document.getElementById('matchesTable');
        dom.matchesBody = document.getElementById('matchesBody');
        dom.emptyState = document.getElementById('emptyState');
        dom.solve = document.getElementById('solveButton');
        dom.resultsCard = document.getElementById('resultsCard');
        dom.resultLat = document.getElementById('resultLat');
        dom.resultLng = document.getElementById('resultLng');
        dom.resultAlt = document.getElementById('resultAlt');
        dom.resultHeading = document.getElementById('resultHeading');
        dom.resultTilt = document.getElementById('resultTilt');
        dom.resultReproj = document.getElementById('resultReproj');
        dom.zoomIn = document.getElementById('zoomIn');
        dom.zoomOut = document.getElementById('zoomOut');
        dom.tiltUp = document.getElementById('tiltUp');
        dom.tiltDown = document.getElementById('tiltDown');
        dom.rotateLeft = document.getElementById('rotateLeft');
        dom.rotateRight = document.getElementById('rotateRight');
        dom.resetView = document.getElementById('resetView');
        dom.themeButton = document.getElementById('themeButton');
        dom.themePanel = document.getElementById('themePanel');
        dom.themeClose = document.getElementById('themeClose');
        dom.themePresetList = document.getElementById('themePresetList');
        dom.customThemeList = document.getElementById('customThemeList');
        dom.customThemeForm = document.getElementById('customThemeForm');
        dom.customThemeFields = document.getElementById('customThemeFields');
        dom.customThemeName = document.getElementById('customThemeName');
        dom.clearCustomThemes = document.getElementById('clearCustomThemes');
        dom.modelForm = document.getElementById('modelForm');
        dom.modelList = document.getElementById('modelList');
        dom.modelName = document.getElementById('modelName');
        dom.modelFile = document.getElementById('modelFile');
        dom.modelLat = document.getElementById('modelLat');
        dom.modelLng = document.getElementById('modelLng');
        dom.modelAlt = document.getElementById('modelAlt');
        dom.modelScale = document.getElementById('modelScale');
        dom.modelHeading = document.getElementById('modelHeading');
        dom.clearModels = document.getElementById('clearModels');
        dom.aiModel = document.getElementById('aiModelSelect');
        dom.aiRefreshModels = document.getElementById('aiRefreshModels');
        dom.aiAutoButton = document.getElementById('aiAutoButton');
        if (dom.aiAutoButton) {
          dom.aiAutoButton.dataset.label = dom.aiAutoButton.textContent || 'Auto-localizza con IA';
        }
        dom.aiStatus = document.getElementById('aiStatus');
        dom.aiReasoning = document.getElementById('aiReasoning');
      }
      function safeAddEventListener(element, eventName, handler) {
        if (element && typeof element.addEventListener === 'function') {
          element.addEventListener(eventName, handler);
        }
      }
      function init() {
        if (!window.mlMatrix || !window.Cesium) {
          alert('Librerie necessarie non disponibili.');
          return;
        }
        initializeRemoteConsole();
        cacheDom();
        initializeStorage();
        initializeThemeManager();
        initializeModelManager();
        state.image.element = dom.photo;
        state.image.overlay = dom.overlay;
        state.image.ctx = dom.overlay.getContext('2d');
        safeAddEventListener(dom.imageInput, 'change', handleImageSelection);
        safeAddEventListener(dom.imageWrapper, 'click', handleImageClick);
        safeAddEventListener(dom.clear, 'click', () => clearPoints());
        safeAddEventListener(dom.fit, 'click', () => fitImage(true));
        safeAddEventListener(dom.matchesBody, 'click', handleTableClick);
        safeAddEventListener(dom.matchesBody, 'input', handleTableChange);
        safeAddEventListener(dom.solve, 'click', computePose);
        safeAddEventListener(dom.zoomIn, 'click', () => adjustZoom(1));
        safeAddEventListener(dom.zoomOut, 'click', () => adjustZoom(-1));
        safeAddEventListener(dom.resetView, 'click', resetView);
        safeAddEventListener(dom.aiRefreshModels, 'click', (event) => {
          event.preventDefault();
          loadOllamaModels(true);
        });
        safeAddEventListener(dom.aiModel, 'change', handleModelChange);
        safeAddEventListener(dom.aiAutoButton, 'click', handleAutoLocate);
        window.addEventListener('resize', syncOverlaySize);
        if (state.image.element) {
          state.image.element.addEventListener('load', () => {
            state.image.naturalWidth = state.image.element.naturalWidth;
            state.image.naturalHeight = state.image.element.naturalHeight;
            dom.placeholder.style.display = 'none';
            state.image.element.style.display = 'block';
            syncOverlaySize();
            drawOverlay();
            pushStatus('Immagine caricata. Seleziona un punto.', false);
          });
        }
        initMap();
        loadOllamaModels();
      }
      function initializeStorage() {
        try {
          const testKey = '__image_localizator__';
          localStorage.setItem(testKey, '1');
          localStorage.removeItem(testKey);
          state.config.storageAvailable = true;
        } catch (error) {
          state.config.storageAvailable = false;
        }
      }
      function initMap() {
        const { Cesium } = window;
        const imageryProvider = new Cesium.UrlTemplateImageryProvider({
          url: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
          credit: '© OpenStreetMap contributors'
        });
        if (state.map.viewer) {
          state.map.viewer.destroy();
        }
        state.map.markers = new Map();
        state.map.viewer = new Cesium.Viewer('map', {
          imageryProvider,
          terrainProvider: new Cesium.EllipsoidTerrainProvider(),
          sceneMode: Cesium.SceneMode.SCENE2D,
          mapProjection: new Cesium.WebMercatorProjection(),
          baseLayerPicker: false,
          geocoder: false,
          timeline: false,
          animation: false,
          sceneModePicker: false,
          navigationHelpButton: false,
          homeButton: false,
          fullscreenButton: false,
          selectionIndicator: false,
          infoBox: false,
          skyAtmosphere: false,
          skyBox: false,
          shadows: false
        });
        const viewer = state.map.viewer;
        viewer.scene.morphTo2D(0);
        viewer.scene.globe.baseColor = Cesium.Color.fromCssColorString('#050c1e');
        viewer.scene.globe.enableLighting = false;
        viewer.scene.globe.depthTestAgainstTerrain = false;
        viewer.scene.screenSpaceCameraController.enableTilt = false;
        viewer.scene.screenSpaceCameraController.enableLook = false;
        viewer.scene.screenSpaceCameraController.enableRotate = false;
        viewer.scene.screenSpaceCameraController.minimumZoomDistance = 10;
        viewer.scene.screenSpaceCameraController.maximumZoomDistance = 500000;
        viewer.camera.constrainedAxis = Cesium.Cartesian3.UNIT_Z;
        setInitialCameraView();
        setupCameraSync();
        setupSceneInteractions();
        pushStatus('Mappa OSM 2D pronta. Clicca sulla foto, poi sulla mappa.', false);
      }

      function setInitialCameraView() {
        const { Cesium } = window;
        const viewer = state.map.viewer;
        if (!viewer) return;
        const { lat, lng, height } = state.map.defaultView;
        viewer.camera.setView({
          destination: Cesium.Cartesian3.fromDegrees(lng, lat, height),
          orientation: {
            heading: Cesium.Math.toRadians(state.map.view.heading),
            pitch: Cesium.Math.toRadians(state.map.view.pitch),
            roll: 0
          }
        });
      }

      function setupCameraSync() {
        const { Cesium } = window;
        const viewer = state.map.viewer;
        if (!viewer) return;
        viewer.camera.changed.addEventListener(() => {
          state.map.view.pitch = Cesium.Math.toDegrees(viewer.camera.pitch);
          state.map.view.heading = (Cesium.Math.toDegrees(viewer.camera.heading) + 360) % 360;
        });
      }

      function setupSceneInteractions() {
        const { Cesium } = window;
        const viewer = state.map.viewer;
        if (!viewer) return;
        if (state.map.handler) {
          state.map.handler.destroy();
        }
        state.map.dragging = null;
        const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
        state.map.handler = handler;
        handler.setInputAction((movement) => {
          const pick = pickCartographicFromScreenPosition(movement.position);
          if (!pick.cartographic) return;
          const markerId = pick.pickedEntity?.properties?.markerId?.getValue?.();
          if (markerId) {
            return;
          }
          const lat = Cesium.Math.toDegrees(pick.cartographic.latitude);
          const lng = Cesium.Math.toDegrees(pick.cartographic.longitude);
          const height = pick.cartographic.height || 0;
          handleMapClick({ lat, lng, height });
        }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
        handler.setInputAction((movement) => {
          const pick = pickCartographicFromScreenPosition(movement.position);
          const markerId =
            pick.pickedEntity?.properties?.markerId?.getValue?.() ?? pick.pickedEntity?.markerId ?? null;
          if (!markerId) {
            return;
          }
          state.map.dragging = { id: Number(markerId) };
          toggleCameraControls(false);
        }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
        handler.setInputAction((movement) => {
          if (!state.map.dragging) return;
          const pick = pickCartographicFromScreenPosition(movement.endPosition);
          if (!pick.cartographic) return;
          const lat = Cesium.Math.toDegrees(pick.cartographic.latitude);
          const lng = Cesium.Math.toDegrees(pick.cartographic.longitude);
          updateMarkerPosition(state.map.dragging.id, lat, lng, pick.cartographic.height || 0);
        }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
        const stopDragging = () => {
          if (!state.map.dragging) return;
          state.map.dragging = null;
          toggleCameraControls(true);
        };
        handler.setInputAction(stopDragging, Cesium.ScreenSpaceEventType.LEFT_UP);
        handler.setInputAction(stopDragging, Cesium.ScreenSpaceEventType.MOUSE_UP);
      }

      function toggleCameraControls(isEnabled) {
        const controller = state.map.viewer?.scene?.screenSpaceCameraController;
        if (!controller) return;
        controller.enableZoom = isEnabled;
        controller.enablePan = isEnabled;
      }

      function pickCartographicFromScreenPosition(position) {
        const { Cesium } = window;
        const viewer = state.map.viewer;
        const result = { cartographic: null, pickedEntity: null };
        if (!viewer || !position) return result;
        const scene = viewer.scene;
        result.pickedEntity = scene.pick(position);
        let cartesian = null;
        if (scene.pickPositionSupported) {
          cartesian = scene.pickPosition(position);
        }
        if (!cartesian) {
          cartesian = viewer.camera.pickEllipsoid(position, scene.globe.ellipsoid);
        }
        if (!cartesian) {
          return result;
        }
        result.cartographic = Cesium.Cartographic.fromCartesian(cartesian);
        return result;
      }

      function updateMarkerPosition(id, lat, lng, sampledHeight) {
        const entry = state.correspondences.find((item) => item.id === id);
        if (!entry || !entry.mapPoint) {
          return;
        }
        const altitude = Number.isFinite(entry.mapPoint.altitude)
          ? entry.mapPoint.altitude
          : sampledHeight || 0;
        entry.mapPoint.lat = lat;
        entry.mapPoint.lng = lng;
        entry.mapPoint.altitude = altitude;
        entry.mapPoint.ecef = latLngAltToECEF(lat, lng, altitude);
        const marker = state.map.markers.get(id);
        if (marker) {
          const { Cesium } = window;
          marker.position = Cesium.Cartesian3.fromDegrees(lng, lat, altitude);
        }
        updateTable();
      }
      async function handleImageSelection(event) {
        const file = event.target.files?.[0];
        if (!file) return;
        if (state.image.localUrl) {
          URL.revokeObjectURL(state.image.localUrl);
        }
        state.image.localUrl = URL.createObjectURL(file);
        state.image.element.src = state.image.localUrl;
        state.image.uploadInfo = null;
        const uploadToken = Date.now();
        state.image.uploadToken = uploadToken;
        clearPoints(true);
        dom.resultsCard.style.display = 'none';
        if (dom.aiReasoning) {
          dom.aiReasoning.textContent = '';
          dom.aiReasoning.hidden = true;
        }
        setAiStatus('Caricamento immagine sul server...', false);
        try {
          const uploadInfo = await uploadImageToServer(file);
          if (state.image.uploadToken !== uploadToken) {
            return;
          }
          state.image.uploadInfo = uploadInfo;
          setAiStatus('Immagine pronta per l\'analisi IA.', false);
        } catch (error) {
          if (state.image.uploadToken !== uploadToken) {
            return;
          }
          state.image.uploadInfo = null;
          console.error('Errore di upload immagine', error);
          setAiStatus(`Errore upload: ${error.message}`, true);
          pushStatus('Caricamento sul server non riuscito: l\'IA non può analizzare la foto.', true);
        }
      }
      async function uploadImageToServer(file) {
        const formData = new FormData();
        formData.append('image', file);
        const response = await fetch('/api/upload-image', {
          method: 'POST',
          body: formData
        });
        let payload = {};
        try {
          payload = await response.json();
        } catch {
          payload = {};
        }
        if (!response.ok || !payload.success) {
          throw new Error(payload.error || 'Upload non riuscito');
        }
        return {
          filename: payload.filename,
          imageUrl: payload.imageUrl
        };
      }
      function handleImageClick(event) {
        if (!state.image.naturalWidth) return;
        const rect = state.image.element.getBoundingClientRect();
        if (event.clientX < rect.left || event.clientX > rect.right || event.clientY < rect.top || event.clientY > rect.bottom) return;
        const relativeX = (event.clientX - rect.left) / rect.width;
        const relativeY = (event.clientY - rect.top) / rect.height;
        const x = relativeX * state.image.naturalWidth;
        const y = relativeY * state.image.naturalHeight;
        const id = state.nextId++;
        const entry = { id, imagePoint: { x, y }, mapPoint: null, marker: null };
        state.correspondences.push(entry);
        state.pending = { id };
        updateTable();
        drawOverlay();
        highlightPending(id);
        pushStatus(`Punto #${id} aggiunto. Ora selezionalo sulla mappa.`, false);
      }
      function handleMapClick(latlng) {
        if (!state.pending) {
          pushStatus('Seleziona prima un punto sulla foto.', true);
          return;
        }
        const entry = state.correspondences.find((item) => item.id === state.pending.id);
        if (!entry) {
          state.pending = null;
          return;
        }
        if (!state.map.viewer) {
          pushStatus('La mappa OSM non è pronta.', true);
          return;
        }
        if (entry.marker) {
          state.map.viewer.entities.remove(entry.marker);
          state.map.markers.delete(entry.id);
        }
        const altitude = entry.mapPoint?.altitude ?? latlng.height ?? 0;
        entry.mapPoint = {
          lat: latlng.lat,
          lng: latlng.lng,
          altitude,
          ecef: latLngAltToECEF(latlng.lat, latlng.lng, altitude)
        };
        entry.marker = createMarkerEntity(entry);
        state.map.markers.set(entry.id, entry.marker);
        state.pending = null;
        updateTable();
        drawOverlay();
        pushStatus(`Punto #${entry.id} collegato.`, false);
      }

      async function handleAutoLocate(event) {
        event?.preventDefault?.();
        if (state.ai.busy) {
          return;
        }
        if (!state.image.uploadInfo?.filename) {
          setAiStatus('Carica un\'immagine e attendi il caricamento prima di usare l\'IA.', true);
          pushStatus('Carica un\'immagine per l\'analisi IA.', true);
          return;
        }
        if (!state.ai.selectedModel) {
          pushStatus('Seleziona un modello Ollama prima di procedere.', true);
          dom.aiModel?.focus();
          return;
        }
        if (!state.image.naturalWidth || !state.image.naturalHeight) {
          pushStatus('Attendi che l\'immagine sia completamente caricata.', true);
          return;
        }
        setAiBusy(true);
        setAiStatus('Analisi IA in corso...', false);
        try {
          const payload = {
            model: state.ai.selectedModel,
            filename: state.image.uploadInfo.filename,
            existingPoints: state.correspondences
              .filter((entry) => entry.imagePoint)
              .map((entry) => ({
                id: entry.id,
                label: `P${entry.id}`,
                xNorm: entry.imagePoint.x / state.image.naturalWidth,
                yNorm: entry.imagePoint.y / state.image.naturalHeight,
                description: `pixel (${entry.imagePoint.x.toFixed(0)}, ${entry.imagePoint.y.toFixed(0)})`
              }))
          };
          const response = await fetch('/api/ollama/autolocate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          const data = await response.json().catch(() => ({}));
          if (!response.ok || !data.success) {
            throw new Error(data.error || 'Risposta non valida da Ollama');
          }
          applyAiSuggestions(data);
        } catch (error) {
          console.error('handleAutoLocate', error);
          setAiStatus(`Errore IA: ${error.message}`, true);
          pushStatus('Assistente IA: nessun risultato disponibile.', true);
        } finally {
          setAiBusy(false);
        }
      }

      function applyAiSuggestions(data) {
        const suggestions = Array.isArray(data.suggestions) ? data.suggestions : [];
        const added = [];
        suggestions.forEach((suggestion) => {
          const normalized = normalizeAiSuggestion(suggestion);
          if (!normalized) {
            return;
          }
          const entry = {
            id: state.nextId++,
            imagePoint: normalized.imagePoint,
            mapPoint: {
              lat: normalized.lat,
              lng: normalized.lng,
              altitude: normalized.altitude,
              ecef: latLngAltToECEF(normalized.lat, normalized.lng, normalized.altitude)
            },
            marker: null
          };
          entry.marker = createMarkerEntity(entry);
          state.map.markers.set(entry.id, entry.marker);
          state.correspondences.push(entry);
          added.push(entry);
        });
        if (dom.aiReasoning) {
          const reasoning = (data.analysis || data.raw || '').trim();
          dom.aiReasoning.textContent = reasoning;
          dom.aiReasoning.hidden = !reasoning;
        }
        if (!added.length) {
          setAiStatus('IA: nessun punto valido restituito.', true);
          return;
        }
        state.pending = null;
        updateTable();
        drawOverlay();
        setAiStatus(`IA: aggiunti ${added.length} punti.`, false);
        pushStatus(`IA: aggiunti ${added.length} nuovi punti sulla mappa.`, false);
        if (data.pose) {
          applyAiPose(data.pose);
        }
      }

      function normalizeAiSuggestion(suggestion) {
        if (!suggestion) {
          return null;
        }
        const location = suggestion.mapPoint || suggestion.location || suggestion;
        const lat = Number(location.lat ?? location.latitude);
        const lng = Number(location.lng ?? location.lon ?? location.longitude);
        if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
          return null;
        }
        const altitude = Number(location.altitude ?? location.alt ?? 0) || 0;
        const imageCandidate = suggestion.imagePoint || suggestion.image || null;
        const fallback = state.image.naturalWidth && state.image.naturalHeight
          ? convertNormalizedToPixels(0.5, 0.5)
          : null;
        const imagePoint = convertNormalizedToPixels(
          Number(imageCandidate?.xNorm ?? imageCandidate?.x),
          Number(imageCandidate?.yNorm ?? imageCandidate?.y)
        ) || fallback;
        return {
          lat,
          lng,
          altitude,
          imagePoint
        };
      }

      function convertNormalizedToPixels(xNorm, yNorm) {
        if (!state.image.naturalWidth || !state.image.naturalHeight) {
          return null;
        }
        const clamp = (value) => {
          if (!Number.isFinite(value)) return 0.5;
          return Math.min(1, Math.max(0, value));
        };
        const safeX = clamp(xNorm);
        const safeY = clamp(yNorm);
        return {
          x: safeX * state.image.naturalWidth,
          y: safeY * state.image.naturalHeight
        };
      }

      function applyAiPose(pose) {
        if (!dom.resultsCard) {
          return;
        }
        const lat = Number(pose.lat ?? pose.latitude);
        const lng = Number(pose.lng ?? pose.lon ?? pose.longitude);
        const altitude = Number(pose.altitude ?? pose.alt);
        const heading = Number(pose.heading);
        const tilt = Number(pose.tilt ?? pose.pitch);
        if (Number.isFinite(lat)) {
          dom.resultLat.textContent = `${lat.toFixed(6)}°`;
        }
        if (Number.isFinite(lng)) {
          dom.resultLng.textContent = `${lng.toFixed(6)}°`;
        }
        if (Number.isFinite(altitude)) {
          dom.resultAlt.textContent = `${altitude.toFixed(2)} m`;
        }
        if (Number.isFinite(heading)) {
          dom.resultHeading.textContent = `${heading.toFixed(1)}°`;
        }
        if (Number.isFinite(tilt)) {
          dom.resultTilt.textContent = `${tilt.toFixed(1)}°`;
        }
        dom.resultReproj.textContent = pose.reprojectionError
          ? `${Number(pose.reprojectionError).toFixed(2)} px`
          : 'stima IA';
        dom.resultsCard.style.display = 'grid';
      }

      async function loadOllamaModels(force = false) {
        if (!dom.aiModel || (state.ai.loadingModels && !force)) {
          return;
        }
        state.ai.loadingModels = true;
        renderModelOptions();
        try {
          setAiStatus('Recupero modelli da Ollama...', false);
          const response = await fetch('/api/ollama/models');
          const payload = await response.json().catch(() => ({}));
          if (!response.ok || !payload.success) {
            throw new Error(payload.error || 'Richiesta non valida');
          }
          state.ai.models = Array.isArray(payload.models) ? payload.models : [];
          if (state.ai.models.length) {
            const currentExists = state.ai.models.some((model) => model.name === state.ai.selectedModel);
            if (!currentExists) {
              const preferred = state.ai.models.find((model) => /vision|llava|image/i.test(model.name)) || state.ai.models[0];
              state.ai.selectedModel = preferred?.name || '';
            }
          } else {
            state.ai.selectedModel = '';
          }
          renderModelOptions();
          const message = state.ai.models.length
            ? `Modelli trovati: ${state.ai.models.length}`
            : 'Nessun modello disponibile su Ollama.';
          setAiStatus(message, !state.ai.models.length);
        } catch (error) {
          console.error('loadOllamaModels', error);
          state.ai.models = [];
          renderModelOptions();
          setAiStatus(`Errore modelli: ${error.message}`, true);
        } finally {
          state.ai.loadingModels = false;
        }
      }

      function renderModelOptions() {
        if (!dom.aiModel) return;
        dom.aiModel.innerHTML = '';
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = state.ai.loadingModels ? 'Caricamento...' : 'Seleziona un modello';
        placeholder.disabled = true;
        placeholder.selected = !state.ai.selectedModel;
        dom.aiModel.appendChild(placeholder);
        state.ai.models.forEach((model) => {
          const option = document.createElement('option');
          option.value = model.name;
          const family = model.family ? ` – ${model.family}` : '';
          option.textContent = `${model.name}${family}`;
          dom.aiModel.appendChild(option);
        });
        if (state.ai.selectedModel) {
          dom.aiModel.value = state.ai.selectedModel;
        }
      }

      function handleModelChange(event) {
        state.ai.selectedModel = event.target.value;
        if (state.ai.selectedModel) {
          setAiStatus(`Modello selezionato: ${state.ai.selectedModel}`, false);
        }
      }

      function setAiStatus(message, isError) {
        if (!dom.aiStatus) {
          return;
        }
        dom.aiStatus.textContent = message || '';
        dom.aiStatus.dataset.state = isError ? 'error' : 'info';
        dom.aiStatus.hidden = !message;
      }

      function setAiBusy(isBusy) {
        state.ai.busy = isBusy;
        if (dom.aiAutoButton) {
          dom.aiAutoButton.disabled = isBusy;
          const label = dom.aiAutoButton.dataset.label || 'Auto-localizza con IA';
          dom.aiAutoButton.textContent = isBusy ? 'Analisi IA in corso...' : label;
        }
      }

      function createMarkerEntity(entry) {
        const viewer = state.map.viewer;
        if (!viewer || !entry.mapPoint) {
          return null;
        }
        const { Cesium } = window;
        const altitude = entry.mapPoint.altitude ?? 0;
        const position = Cesium.Cartesian3.fromDegrees(entry.mapPoint.lng, entry.mapPoint.lat, altitude);
        const pinBuilder = new Cesium.PinBuilder();
        const markerEntity = viewer.entities.add({
          position,
          billboard: {
            image: pinBuilder.fromColor(Cesium.Color.fromCssColorString('#f97316'), 48),
            verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
            scale: 0.85
          },
          label: {
            text: `#${entry.id}`,
            pixelOffset: new Cesium.Cartesian2(0, -48),
            fillColor: Cesium.Color.WHITE,
            outlineColor: Cesium.Color.fromCssColorString('#020617'),
            outlineWidth: 3,
            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
            verticalOrigin: Cesium.VerticalOrigin.BOTTOM
          },
          properties: {
            markerId: entry.id
          }
        });
        markerEntity.markerId = entry.id;
        return markerEntity;
      }
      function clearPoints(skipStatus = false) {
        state.correspondences.forEach((entry) => {
          if (entry.marker) {
            state.map.viewer?.entities.remove(entry.marker);
          }
        });
        state.map.markers?.clear();
        state.correspondences = [];
        state.pending = null;
        state.nextId = 1;
        updateTable();
        drawOverlay();
        dom.resultsCard.style.display = 'none';
        if (!skipStatus) {
          pushStatus('Punti rimossi.', false);
        }
      }
      function fitImage(notify) {
        if (!state.image.naturalWidth) return;
        state.image.element.style.width = '100%';
        state.image.element.style.height = 'auto';
        syncOverlaySize();
        if (notify) pushStatus('Immagine adattata al contenitore.', false);
      }
      function syncOverlaySize() {
        if (!state.image.naturalWidth) return;
        const rect = state.image.element.getBoundingClientRect();
        state.image.overlay.width = rect.width;
        state.image.overlay.height = rect.height;
        state.image.overlay.style.width = `${rect.width}px`;
        state.image.overlay.style.height = `${rect.height}px`;
        drawOverlay();
      }
      function drawOverlay() {
        const ctx = state.image.ctx;
        if (!ctx) return;
        ctx.clearRect(0, 0, state.image.overlay.width, state.image.overlay.height);
        ctx.lineWidth = 2;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        state.correspondences.forEach((entry) => {
          if (!entry.imagePoint) return;
          const { x, y } = toDisplay(entry.imagePoint);
          const pending = state.pending?.id === entry.id;
          ctx.fillStyle = pending ? '#f97316' : '#38bdf8';
          ctx.strokeStyle = 'rgba(0,0,0,0.4)';
          ctx.beginPath();
          ctx.arc(x, y, 7, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = '#04122e';
          ctx.font = '600 11px "Segoe UI"';
          ctx.fillText(entry.id, x, y + 0.5);
        });
      }
      function toDisplay(point) {
        const rect = state.image.element.getBoundingClientRect();
        return {
          x: point.x * (rect.width / state.image.naturalWidth),
          y: point.y * (rect.height / state.image.naturalHeight)
        };
      }
      function updateTable() {
        dom.matchesBody.innerHTML = '';
        if (!state.correspondences.length) {
          dom.matchesTable.style.display = 'none';
          dom.emptyState.style.display = 'block';
          return;
        }
        dom.matchesTable.style.display = 'table';
        dom.emptyState.style.display = 'none';
        state.correspondences.forEach((entry) => {
          const tr = document.createElement('tr');
          tr.dataset.id = entry.id.toString();
          const coords = entry.mapPoint
            ? `<div>Lat: ${entry.mapPoint.lat.toFixed(6)}</div><div>Lng: ${entry.mapPoint.lng.toFixed(6)}</div>`
            : '<div class="secondary">Clicca sulla mappa</div>';
          const altitude = entry.mapPoint?.altitude ?? '';
          tr.innerHTML = `
            <td><span class="badge">${entry.id}</span></td>
            <td>${entry.imagePoint.x.toFixed(1)}, ${entry.imagePoint.y.toFixed(1)}</td>
            <td>${coords}</td>
            <td><input type="number" class="altitude-input" data-id="${entry.id}" value="${altitude}" step="0.1" placeholder="Alt"></td>
            <td><button data-action="remove" data-id="${entry.id}">Rimuovi</button></td>
          `;
          dom.matchesBody.appendChild(tr);
        });
        if (state.pending) highlightPending(state.pending.id);
      }
      function highlightPending(id) {
        dom.matchesBody.querySelectorAll('tr').forEach((row) => {
          row.style.background = Number(row.dataset.id) === id ? 'rgba(249,115,22,0.18)' : '';
        });
      }
      function handleTableClick(event) {
        const target = event.target;
        if (!(target instanceof HTMLElement)) return;
        if (target.dataset.action === 'remove') {
          removeCorrespondence(Number(target.dataset.id));
        }
      }
      function handleTableChange(event) {
        const target = event.target;
        if (!(target instanceof HTMLInputElement)) return;
        if (!target.classList.contains('altitude-input')) return;
        const id = Number(target.dataset.id);
        const value = Number(target.value);
        if (Number.isNaN(value)) return;
        const entry = state.correspondences.find((item) => item.id === id);
        if (entry && entry.mapPoint) {
          entry.mapPoint.altitude = value;
          entry.mapPoint.ecef = latLngAltToECEF(entry.mapPoint.lat, entry.mapPoint.lng, value);
          const marker = state.map.markers.get(id);
          if (marker) {
            const { Cesium } = window;
            marker.position = Cesium.Cartesian3.fromDegrees(entry.mapPoint.lng, entry.mapPoint.lat, value);
          }
        }
      }
      function removeCorrespondence(id) {
        const index = state.correspondences.findIndex((entry) => entry.id === id);
        if (index === -1) return;
        const [removed] = state.correspondences.splice(index, 1);
        if (removed?.marker) {
          state.map.viewer?.entities.remove(removed.marker);
          state.map.markers?.delete(removed.id);
        }
        if (state.pending?.id === id) {
          state.pending = null;
        }
        updateTable();
        drawOverlay();
        pushStatus(`Corrispondenza #${id} rimossa.`, false);
      }
      function pushStatus(message, isError) {
        dom.statusBanner.style.background = isError ? 'rgba(244,63,94,0.18)' : 'rgba(56,189,248,0.12)';
        dom.statusBanner.style.borderColor = isError ? 'rgba(244,63,94,0.4)' : 'rgba(56,189,248,0.4)';
        dom.statusMessage.textContent = message;
      }
      function getCamera() {
        return state.map.viewer?.camera ?? null;
      }

      function adjustZoom(delta) {
        const viewer = state.map.viewer;
        if (!viewer) return;
        const camera = viewer.camera;
        const amount = Math.max(5, camera.positionCartographic.height * 0.15);
        if (delta > 0) {
          camera.zoomIn(amount);
        } else {
          camera.zoomOut(amount);
        }
      }

      function adjustTilt(delta) {
        const camera = getCamera();
        if (!camera) return;
        state.map.view.pitch = Math.min(-5, Math.max(-80, state.map.view.pitch + delta));
        const { Cesium } = window;
        camera.setView({
          destination: camera.position,
          orientation: {
            heading: Cesium.Math.toRadians(state.map.view.heading),
            pitch: Cesium.Math.toRadians(state.map.view.pitch),
            roll: 0
          }
        });
      }

      function adjustRotation(delta) {
        const camera = getCamera();
        if (!camera) return;
        state.map.view.heading = (state.map.view.heading + delta + 360) % 360;
        const { Cesium } = window;
        camera.setView({
          destination: camera.position,
          orientation: {
            heading: Cesium.Math.toRadians(state.map.view.heading),
            pitch: Cesium.Math.toRadians(state.map.view.pitch),
            roll: 0
          }
        });
      }

      function resetView() {
        const viewer = state.map.viewer;
        if (!viewer) return;
        const { Cesium } = window;
        const { lat, lng, height } = state.map.defaultView;
        state.map.view.pitch = -90;
        state.map.view.heading = 0;
        viewer.camera.flyTo({
          destination: Cesium.Cartesian3.fromDegrees(lng, lat, height),
          orientation: {
            heading: 0,
            pitch: Cesium.Math.toRadians(state.map.view.pitch),
            roll: 0
          },
          duration: 0.8
        });
      }

      function initializeThemeManager() {
        if (!dom.themeButton || !dom.themePanel) {
          return;
        }
        buildCustomThemeFields();
        if (state.config.storageAvailable) {
          state.theme.custom = loadCustomThemes();
          const storedActive = localStorage.getItem(STORAGE_KEYS.activeTheme);
          if (storedActive && (THEME_PRESETS[storedActive] || state.theme.custom[storedActive])) {
            state.theme.active = storedActive;
          }
        }
        applyTheme(state.theme.active);
        renderThemeLists();
        safeAddEventListener(dom.themeButton, 'click', toggleThemePanel);
        safeAddEventListener(dom.themeClose, 'click', () => closeThemePanel(true));
        safeAddEventListener(dom.themePresetList, 'click', handleThemeChipClick);
        safeAddEventListener(dom.customThemeList, 'click', handleThemeChipClick);
        safeAddEventListener(dom.customThemeForm, 'submit', handleCustomThemeSubmit);
        safeAddEventListener(dom.clearCustomThemes, 'click', clearAllCustomThemes);
        document.addEventListener('click', handleThemeOutsideClick);
        document.addEventListener('keydown', (event) => {
          if (event.key === 'Escape') {
            closeThemePanel();
          }
        });
      }

      function buildCustomThemeFields() {
        if (!dom.customThemeFields) {
          return;
        }
        dom.customThemeFields.innerHTML = '';
        THEME_VARIABLES.forEach(({ key, label, defaultValue }) => {
          const wrapper = document.createElement('div');
          wrapper.className = 'theme-color-picker';
          const inputId = `theme-color-${key.replace(/^-+/, '')}`;
          wrapper.innerHTML = `
            <label for="${inputId}">${label}</label>
            <input type="color" id="${inputId}" data-variable="${key}" value="${defaultValue}">
          `;
          dom.customThemeFields.appendChild(wrapper);
        });
        populateCustomThemeFields();
      }

      function populateCustomThemeFields(values) {
        if (!dom.customThemeFields) {
          return;
        }
        const themeValues = values || getThemeDefinition(state.theme.active)?.values || {};
        THEME_VARIABLES.forEach(({ key, defaultValue }) => {
          const input = dom.customThemeFields.querySelector(`[data-variable="${key}"]`);
          if (!input) {
            return;
          }
          const value = themeValues[key] || defaultValue || '#000000';
          input.value = normalizeColor(value, defaultValue || '#000000');
        });
      }

      function renderThemeLists() {
        if (!dom.themePresetList || !dom.customThemeList) {
          return;
        }
        dom.themePresetList.innerHTML = '';
        Object.entries(THEME_PRESETS).forEach(([name, definition]) => {
          dom.themePresetList.appendChild(createThemeChip(name, definition, false));
        });
        dom.customThemeList.innerHTML = '';
        const customEntries = Object.entries(state.theme.custom);
        customEntries.forEach(([name, definition]) => {
          dom.customThemeList.appendChild(createThemeChip(name, definition, true));
        });
        const isEmpty = customEntries.length === 0;
        dom.customThemeList.dataset.empty = isEmpty ? 'true' : 'false';
        if (dom.clearCustomThemes) {
          dom.clearCustomThemes.hidden = isEmpty;
        }
      }

      function createThemeChip(name, definition, isCustom) {
        const wrapper = document.createElement('div');
        wrapper.className = 'theme-chip';
        wrapper.dataset.theme = name;
        wrapper.dataset.active = state.theme.active === name ? 'true' : 'false';
        const selectButton = document.createElement('button');
        selectButton.type = 'button';
        selectButton.className = 'theme-chip__select';
        selectButton.dataset.themeSelect = name;
        selectButton.textContent = definition.label || name;
        wrapper.appendChild(selectButton);
        if (isCustom) {
          const deleteButton = document.createElement('button');
          deleteButton.type = 'button';
          deleteButton.className = 'theme-chip__delete';
          deleteButton.dataset.themeDelete = name;
          deleteButton.setAttribute('aria-label', `Elimina il tema ${definition.label || name}`);
          deleteButton.textContent = '×';
          wrapper.appendChild(deleteButton);
        }
        return wrapper;
      }

      function handleThemeChipClick(event) {
        const deleteBtn = event.target.closest('[data-theme-delete]');
        if (deleteBtn) {
          const themeName = deleteBtn.dataset.themeDelete;
          delete state.theme.custom[themeName];
          saveCustomThemes();
          if (state.theme.active === themeName) {
            applyTheme('aurora');
          } else {
            renderThemeLists();
          }
          return;
        }
        const selectBtn = event.target.closest('[data-theme-select]');
        if (selectBtn) {
          applyTheme(selectBtn.dataset.themeSelect);
          closeThemePanel();
        }
      }

      function handleCustomThemeSubmit(event) {
        event.preventDefault();
        if (!dom.customThemeName) {
          return;
        }
        const label = dom.customThemeName.value.trim();
        if (!label) {
          dom.customThemeName.focus();
          return;
        }
        const themeValues = {};
        THEME_VARIABLES.forEach(({ key, defaultValue }) => {
          const input = dom.customThemeFields.querySelector(`[data-variable="${key}"]`);
          themeValues[key] = (input?.value || defaultValue).trim();
        });
        const themeId = generateThemeId(label);
        state.theme.custom[themeId] = { label, values: themeValues };
        saveCustomThemes();
        dom.customThemeForm.reset();
        populateCustomThemeFields(themeValues);
        renderThemeLists();
        applyTheme(themeId);
      }

      function clearAllCustomThemes() {
        if (!Object.keys(state.theme.custom).length) {
          return;
        }
        if (!confirm('Vuoi eliminare tutti i temi personalizzati?')) {
          return;
        }
        state.theme.custom = {};
        saveCustomThemes();
        renderThemeLists();
      }

      function initializeModelManager() {
        if (!dom.modelForm || !dom.modelList) {
          return;
        }
        dom.modelLat.value = state.map.defaultView.lat.toFixed(6);
        dom.modelLng.value = state.map.defaultView.lng.toFixed(6);
        renderModelList();
        safeAddEventListener(dom.modelForm, 'submit', handleModelSubmit);
        safeAddEventListener(dom.modelList, 'click', handleModelListClick);
        safeAddEventListener(dom.clearModels, 'click', clearAllModels);
      }

      function handleModelSubmit(event) {
        event.preventDefault();
        if (!dom.modelFile?.files?.length) {
          pushStatus('Seleziona un file GLB/GLTF valido.', true);
          return;
        }
        if (!state.map.viewer) {
          pushStatus('La mappa OSM non è pronta.', true);
          return;
        }
        const file = dom.modelFile.files[0];
        const name = dom.modelName.value.trim() || file.name;
        const lat = Number(dom.modelLat.value);
        const lng = Number(dom.modelLng.value);
        const altitude = Number(dom.modelAlt.value) || 0;
        const scale = Math.max(0.01, Number(dom.modelScale.value) || 1);
        const heading = Number(dom.modelHeading.value) || 0;
        if ([lat, lng].some((value) => Number.isNaN(value))) {
          pushStatus('Inserisci coordinate valide per il modello 3D.', true);
          return;
        }
        const id = state.models.nextId++;
        const objectUrl = URL.createObjectURL(file);
        const entry = {
          id,
          name,
          fileName: file.name,
          lat,
          lng,
          altitude,
          scale,
          heading,
          objectUrl,
          entity: null
        };
        entry.entity = addModelToScene(entry);
        if (!entry.entity) {
          URL.revokeObjectURL(objectUrl);
          pushStatus('Impossibile caricare il modello selezionato.', true);
          return;
        }
        state.models.entries.set(id, entry);
        renderModelList();
        dom.modelForm.reset();
        dom.modelLat.value = state.map.defaultView.lat.toFixed(6);
        dom.modelLng.value = state.map.defaultView.lng.toFixed(6);
        dom.modelAlt.value = '35';
        dom.modelScale.value = '1';
        dom.modelHeading.value = '0';
        pushStatus(`Modello "${entry.name}" aggiunto alla scena.`, false);
      }

      function addModelToScene(entry) {
        if (!state.map.viewer) {
          return null;
        }
        const { Cesium } = window;
        const position = Cesium.Cartesian3.fromDegrees(entry.lng, entry.lat, entry.altitude || 0);
        const orientation = Cesium.Transforms.headingPitchRollQuaternion(
          position,
          new Cesium.HeadingPitchRoll(Cesium.Math.toRadians(entry.heading || 0), 0, 0)
        );
        return state.map.viewer.entities.add({
          name: entry.name,
          position,
          orientation,
          model: {
            uri: entry.objectUrl,
            scale: entry.scale,
            minimumPixelSize: 64,
            maximumScale: 10000
          },
          properties: {
            customModelId: entry.id
          }
        });
      }

      function renderModelList() {
        if (!dom.modelList) {
          return;
        }
        const entries = Array.from(state.models.entries.values());
        if (!entries.length) {
          dom.modelList.dataset.empty = 'true';
          dom.modelList.innerHTML = `<p class="model-empty">${dom.modelList.dataset.emptyMessage || 'Nessun modello caricato.'}</p>`;
          return;
        }
        dom.modelList.dataset.empty = 'false';
        dom.modelList.innerHTML = '';
        entries.forEach((entry) => {
          const item = document.createElement('div');
          item.className = 'model-list__item';
          item.innerHTML = `
            <div>
              <strong>${entry.name}</strong>
              <div class="model-meta">Lat ${entry.lat.toFixed(5)} · Lng ${entry.lng.toFixed(5)} · Alt ${entry.altitude?.toFixed(1) ?? 0} m · Scala ${entry.scale}</div>
            </div>
            <button type="button" data-model-remove="${entry.id}">Rimuovi</button>
          `;
          dom.modelList.appendChild(item);
        });
      }

      function handleModelListClick(event) {
        const button = event.target.closest('[data-model-remove]');
        if (!button) {
          return;
        }
        removeModel(Number(button.dataset.modelRemove));
      }

      function removeModel(id, silent = false) {
        const entry = state.models.entries.get(id);
        if (!entry) {
          return;
        }
        if (entry.entity) {
          state.map.viewer?.entities.remove(entry.entity);
        }
        if (entry.objectUrl) {
          URL.revokeObjectURL(entry.objectUrl);
        }
        state.models.entries.delete(id);
        renderModelList();
        if (!silent) {
          pushStatus(`Modello "${entry.name}" rimosso.`, false);
        }
      }

      function clearAllModels() {
        if (!state.models.entries.size) {
          return;
        }
        if (!confirm('Vuoi rimuovere tutti i modelli personalizzati?')) {
          return;
        }
        Array.from(state.models.entries.keys()).forEach((id) => removeModel(id, true));
        renderModelList();
        pushStatus('Modelli personalizzati rimossi.', false);
      }

      function toggleThemePanel() {
        setThemePanelVisibility(dom.themePanel?.hidden);
      }

      function closeThemePanel(focusButton = false) {
        setThemePanelVisibility(false, focusButton);
      }

      function setThemePanelVisibility(isVisible, focusButton = false) {
        if (!dom.themePanel || !dom.themeButton) {
          return;
        }
        if (isVisible) {
          dom.themePanel.hidden = false;
          dom.themePanel.classList.add('theme-panel--open');
          dom.themeButton.setAttribute('aria-expanded', 'true');
          populateCustomThemeFields();
        } else {
          dom.themePanel.hidden = true;
          dom.themePanel.classList.remove('theme-panel--open');
          dom.themeButton.setAttribute('aria-expanded', 'false');
          if (focusButton) {
            dom.themeButton.focus();
          }
        }
      }

      function handleThemeOutsideClick(event) {
        if (!dom.themePanel || dom.themePanel.hidden) {
          return;
        }
        const insidePanel = dom.themePanel.contains(event.target);
        const onButton = dom.themeButton?.contains(event.target);
        if (!insidePanel && !onButton) {
          closeThemePanel();
        }
      }

      function applyTheme(themeName) {
        const definition = getThemeDefinition(themeName);
        if (!definition) {
          return;
        }
        Object.entries(definition.values).forEach(([variable, value]) => {
          document.documentElement.style.setProperty(variable, value);
        });
        state.theme.active = themeName;
        if (state.config.storageAvailable) {
          localStorage.setItem(STORAGE_KEYS.activeTheme, themeName);
        }
        renderThemeLists();
        populateCustomThemeFields(definition.values);
      }

      function getThemeDefinition(name) {
        return THEME_PRESETS[name] || state.theme.custom[name] || null;
      }

      function saveCustomThemes() {
        if (!state.config.storageAvailable) {
          return;
        }
        localStorage.setItem(STORAGE_KEYS.customThemes, JSON.stringify(state.theme.custom));
      }

      function loadCustomThemes() {
        if (!state.config.storageAvailable) {
          return {};
        }
        try {
          const stored = localStorage.getItem(STORAGE_KEYS.customThemes);
          return stored ? JSON.parse(stored) : {};
        } catch (error) {
          return {};
        }
      }

      function normalizeColor(value, fallback) {
        const trimmed = (value || '').trim();
        if (trimmed.startsWith('#') && (trimmed.length === 7 || trimmed.length === 4)) {
          return trimmed.length === 4
            ? `#${trimmed[1]}${trimmed[1]}${trimmed[2]}${trimmed[2]}${trimmed[3]}${trimmed[3]}`
            : trimmed;
        }
        return fallback || '#000000';
      }

      function generateThemeId(label) {
        const base = label
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, '-')
          .replace(/^-+|-+$/g, '') || 'tema';
        let candidate = base;
        let counter = 1;
        while (THEME_PRESETS[candidate] || state.theme.custom[candidate]) {
          candidate = `${base}-${counter++}`;
        }
        return candidate;
      }
      function computePose() {
        if (!window.mlMatrix) {
          pushStatus('ml-matrix non disponibile: impossibile stimare la posa.', true);
          return;
        }
        const usable = state.correspondences.filter((entry) => entry.imagePoint && entry.mapPoint?.ecef);
        if (usable.length < 6) {
          pushStatus('Servono almeno 6 corrispondenze complete per stimare la posa.', true);
          return;
        }
        try {
          const { Matrix, SVD } = window.mlMatrix;
          const Adata = [];
          usable.forEach((entry) => {
            const { x, y } = entry.imagePoint;
            const { x: X, y: Y, z: Z } = entry.mapPoint.ecef;
            Adata.push([X, Y, Z, 1, 0, 0, 0, 0, -x * X, -x * Y, -x * Z, -x]);
            Adata.push([0, 0, 0, 0, X, Y, Z, 1, -y * X, -y * Y, -y * Z, -y]);
          });
          const A = new Matrix(Adata);
          const svd = new SVD(A);
          const V = svd.rightSingularVectors;
          const h = V.getColumn(V.columns - 1);
          const P = Matrix.from1DArray(3, 4, h);
          const M = P.subMatrix(0, 2, 0, 2);
          const p4 = P.subMatrix(0, 2, 3, 3);
          const Minv = invert3x3(M, Matrix);
          const c = Minv.mmul(p4);
          const cameraECEF = { x: -c.get(0, 0), y: -c.get(1, 0), z: -c.get(2, 0) };
          const geo = ecefToGeodetic(cameraECEF.x, cameraECEF.y, cameraECEF.z);
          dom.resultLat.textContent = `${geo.lat.toFixed(6)}°`;
          dom.resultLng.textContent = `${geo.lng.toFixed(6)}°`;
          dom.resultAlt.textContent = `${geo.altitude.toFixed(2)} m`;
          try {
            const { R } = decomposeKR(M, Matrix);
            const forward = cameraForwardVector(R);
            const { heading, tilt } = computeViewAngles(forward, cameraECEF);
            dom.resultHeading.textContent = `${heading.toFixed(1)}°`;
            dom.resultTilt.textContent = `${tilt.toFixed(1)}°`;
          } catch (orientationError) {
            dom.resultHeading.textContent = 'n/d';
            dom.resultTilt.textContent = 'n/d';
          }
          const reprojectionError = computeReprojectionError(P, usable);
          dom.resultReproj.textContent = `${reprojectionError.toFixed(2)} px`;
          dom.resultsCard.style.display = 'grid';
          pushStatus('Posa stimata. Verifica i risultati.', false);
        } catch (error) {
          console.error(error);
          pushStatus('Errore nel calcolo della posa.', true);
        }
      }
      function computeReprojectionError(P, correspondences) {
        const { Matrix } = window.mlMatrix;
        let total = 0;
        let count = 0;
        correspondences.forEach((entry) => {
          const world = entry.mapPoint.ecef;
          const point = Matrix.columnVector([world.x, world.y, world.z, 1]);
          const projected = P.mmul(point);
          const w = projected.get(2, 0);
          if (Math.abs(w) < 1e-9) return;
          const x = projected.get(0, 0) / w;
          const y = projected.get(1, 0) / w;
          total += Math.hypot(x - entry.imagePoint.x, y - entry.imagePoint.y);
          count += 1;
        });
        return count ? total / count : 0;
      }
      function decomposeKR(M, Matrix) {
        const J = new Matrix([
          [0, 0, 1],
          [0, 1, 0],
          [1, 0, 0]
        ]);
        const QR = new window.mlMatrix.QRDecomposition(J.mmul(M.transpose()));
        let R = QR.QR.transpose().mmul(J);
        let K = J.mmul(QR.R.transpose()).mmul(J);
        const diagSigns = [K.get(0, 0), K.get(1, 1), K.get(2, 2)].map((value) => (value < 0 ? -1 : 1));
        const signMatrix = Matrix.diag(diagSigns);
        K = K.mmul(signMatrix);
        R = signMatrix.mmul(R);
        const scale = K.get(2, 2);
        if (scale !== 0) {
          K = K.mul(1 / scale);
        }
        if (R.det() < 0) {
          R = R.mul(-1);
          K = K.mul(-1);
        }
        return { K, R };
      }
      function cameraForwardVector(R) {
        const Rt = R.transpose();
        const forward = {
          x: Rt.get(0, 2),
          y: Rt.get(1, 2),
          z: Rt.get(2, 2)
        };
        const norm = Math.sqrt(forward.x ** 2 + forward.y ** 2 + forward.z ** 2) || 1;
        return {
          x: forward.x / norm,
          y: forward.y / norm,
          z: forward.z / norm
        };
      }
      function computeViewAngles(forward, cameraECEF) {
        const geo = ecefToGeodetic(cameraECEF.x, cameraECEF.y, cameraECEF.z);
        const enu = ecefVectorToENU(forward, geo.lat, geo.lng);
        const heading = (Math.atan2(enu.east, enu.north) * 180 / Math.PI + 360) % 360;
        const horizontal = Math.sqrt(enu.east ** 2 + enu.north ** 2);
        const pitch = Math.atan2(enu.up, horizontal) * 180 / Math.PI;
        const tilt = Math.max(0, Math.min(90, 90 - pitch));
        return { heading, tilt };
      }
      function ecefVectorToENU(vector, latDeg, lonDeg) {
        const lat = degToRad(latDeg);
        const lon = degToRad(lonDeg);
        const sinLat = Math.sin(lat);
        const cosLat = Math.cos(lat);
        const sinLon = Math.sin(lon);
        const cosLon = Math.cos(lon);
        const east = -sinLon * vector.x + cosLon * vector.y;
        const north = -sinLat * cosLon * vector.x - sinLat * sinLon * vector.y + cosLat * vector.z;
        const up = cosLat * cosLon * vector.x + cosLat * sinLon * vector.y + sinLat * vector.z;
        return { east, north, up };
      }
      function latLngAltToECEF(latDeg, lonDeg, altitude) {
        const a = 6378137.0;
        const e2 = 6.69437999014e-3;
        const lat = degToRad(latDeg);
        const lon = degToRad(lonDeg);
        const cosLat = Math.cos(lat);
        const sinLat = Math.sin(lat);
        const cosLon = Math.cos(lon);
        const sinLon = Math.sin(lon);
        const N = a / Math.sqrt(1 - e2 * sinLat * sinLat);
        const x = (N + altitude) * cosLat * cosLon;
        const y = (N + altitude) * cosLat * sinLon;
        const z = (N * (1 - e2) + altitude) * sinLat;
        return { x, y, z };
      }
      function ecefToGeodetic(x, y, z) {
        const a = 6378137.0;
        const e2 = 6.69437999014e-3;
        const b = a * Math.sqrt(1 - e2);
        const ep2 = (a * a - b * b) / (b * b);
        const p = Math.sqrt(x * x + y * y);
        const theta = Math.atan2(z * a, p * b);
        const sinTheta = Math.sin(theta);
        const cosTheta = Math.cos(theta);
        const lat = Math.atan2(z + ep2 * b * sinTheta ** 3, p - e2 * a * cosTheta ** 3);
        const lon = Math.atan2(y, x);
        const sinLat = Math.sin(lat);
        const N = a / Math.sqrt(1 - e2 * sinLat * sinLat);
        const alt = p / Math.cos(lat) - N;
        return { lat: radToDeg(lat), lng: radToDeg(lon), altitude: alt };
      }
      function invert3x3(M, Matrix) {
        const m = M.to2DArray();
        const [[a, b, c], [d, e, f], [g, h, i]] = m;
        const det = a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);
        if (Math.abs(det) < 1e-9) throw new Error('Matrice non invertibile');
        const inv = [
          [(e * i - f * h) / det, (c * h - b * i) / det, (b * f - c * e) / det],
          [(f * g - d * i) / det, (a * i - c * g) / det, (c * d - a * f) / det],
          [(d * h - e * g) / det, (b * g - a * h) / det, (a * e - b * d) / det]
        ];
        return new Matrix(inv);
      }
      function degToRad(value) { return value * Math.PI / 180; }
      function radToDeg(value) { return value * 180 / Math.PI; }
      document.addEventListener('DOMContentLoaded', () => ImageLocalizatorApp.init());
      return { init };
    })();

      function initializeRemoteConsole() {
        const config = window.LOGGING_CONFIG;
        if (!config?.enabled || typeof window === 'undefined' || window.__REMOTE_CONSOLE_PATCHED__) {
          return;
        }
        window.__REMOTE_CONSOLE_PATCHED__ = true;
        const methods = ['log', 'info', 'warn', 'error'];
        const originalConsole = Object.fromEntries(
          methods.map((method) => [method, console[method]?.bind(console) || console.log.bind(console)])
        );

        function formatLogValue(value) {
          if (value === null || value === undefined) return String(value);
          if (typeof value === 'string') return value;
          if (typeof value === 'number' || typeof value === 'boolean' || typeof value === 'bigint') return String(value);
          if (value instanceof Error) return `${value.name}: ${value.message}`;
          try {
            return JSON.stringify(value);
          } catch {
            return Object.prototype.toString.call(value);
          }
        }

        function safeClone(value) {
          if (value === null || typeof value !== 'object') {
            return value;
          }
          try {
            return JSON.parse(JSON.stringify(value));
          } catch {
            return {
              summary: Object.prototype.toString.call(value),
              value: value?.toString?.()
            };
          }
        }

        function transmitLog(level, args) {
          if (!config.endpoint || typeof fetch !== 'function') {
            return;
          }
          const message = args.map(formatLogValue).join(' ');
          if (!message.trim()) return;
          const payload = { level, message };
          const detailCandidate = args.find((item) => item && typeof item === 'object');
          if (detailCandidate) {
            payload.details = safeClone(detailCandidate);
          }
          const body = JSON.stringify(payload);
          if (config.useBeacon && navigator?.sendBeacon) {
            try {
              const blob = new Blob([body], { type: 'application/json' });
              navigator.sendBeacon(config.endpoint, blob);
              return;
            } catch {
              // fallback to fetch below
            }
          }
          fetch(config.endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body,
            keepalive: true
          }).catch(() => {});
        }

        methods.forEach((method) => {
          console[method] = (...args) => {
            try {
              originalConsole[method](...args);
            } catch {
              originalConsole.log(...args);
            }
            try {
              transmitLog(method === 'log' ? 'info' : method, args);
            } catch {
              // ignore transport errors
            }
          };
        });

        window.AppLogger = {
          log: (...args) => console.log(...args),
          warn: (...args) => console.warn(...args),
          error: (...args) => console.error(...args),
          info: (...args) => console.info(...args)
        };
      }
  </script>
</body>
</html>

