<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image Localizator</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-sA+e2atLYYt1TzMt6chkmO1QF1wHN40fYp3p3p3uWro=" crossorigin="" />
  <style>
    :root {
      color-scheme: dark;
      --bg: #050c1e;
      --panel: #111c3a;
      --panel-2: #0f1a34;
      --accent: #38bdf8;
      --text: #f8fafc;
      --muted: #b0c4ff;
      --border: #24345a;
      --danger: #f43f5e;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      background: var(--bg);
      color: var(--text);
      font-family: "Segoe UI", Arial, sans-serif;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 1.4rem 2rem;
      border-bottom: 1px solid rgba(255,255,255,.05);
      background: #030b1c;
    }

    header h1 {
      margin: 0;
      font-size: 1.6rem;
      letter-spacing: .04em;
    }

    header p {
      margin: .4rem 0 0;
      max-width: 60rem;
      color: var(--muted);
    }

    main {
      flex: 1;
      padding: 1.5rem 2rem 2.5rem;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .status {
      padding: .8rem 1.1rem;
      border-radius: 1rem;
      border: 1px solid rgba(56,189,248,.35);
      background: rgba(56,189,248,.15);
      display: flex;
      gap: .6rem;
      align-items: center;
    }

    .status strong { color: var(--accent); }

    .layout {
      display: flex;
      flex-wrap: wrap;
      gap: 1.4rem;
    }

    .panel {
      flex: 1 1 28rem;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 1rem;
      padding: 1.25rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      box-shadow: 0 25px 50px rgba(3,5,20,.45);
    }

    .panel h2 {
      margin: 0;
      font-size: 1.15rem;
      display: flex;
      align-items: center;
      gap: .5rem;
    }

    .panel h2 span {
      font-size: .85rem;
      color: var(--muted);
      font-weight: 400;
    }

    .upload {
      border: 1px dashed var(--border);
      border-radius: .8rem;
      padding: 1rem;
      background: var(--panel-2);
      text-align: center;
      line-height: 1.4;
    }

    .upload input { display: none; }

    .upload label {
      display: inline-flex;
      margin-top: .6rem;
      padding: .55rem 1.4rem;
      border-radius: 999px;
      border: 1px solid rgba(56,189,248,.5);
      cursor: pointer;
      color: var(--accent);
    }

    .image-box {
      position: relative;
      border: 1px solid var(--border);
      border-radius: .8rem;
      min-height: 24rem;
      background: #030a1b;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .image-box img { max-width: 100%; display: none; }
    .image-box canvas { position: absolute; inset: 0; pointer-events: none; }
    .placeholder { color: var(--muted); padding: 2rem; text-align: center; }

    #map {
      width: 100%;
      height: 32rem;
      border-radius: .8rem;
      border: 1px solid var(--border);
    }

    .notice {
      background: rgba(249,115,22,.12);
      border: 1px solid rgba(249,115,22,.4);
      border-radius: .7rem;
      padding: .6rem .85rem;
      font-size: .85rem;
      color: var(--muted);
    }

    .controls { display: flex; gap: .7rem; flex-wrap: wrap; }
    .controls button {
      border: none;
      border-radius: .6rem;
      padding: .55rem 1rem;
      background: rgba(56,189,248,.18);
      color: var(--accent);
      cursor: pointer;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      border: 1px solid var(--border);
      border-radius: .9rem;
      overflow: hidden;
    }

    th,td {
      padding: .65rem .8rem;
      border-bottom: 1px solid rgba(36,52,90,.6);
      font-size: .85rem;
    }

    thead { background: rgba(10,17,35,.9); }
    tbody tr:hover { background: rgba(56,189,248,.08); }

    .badge {
      display: inline-flex;
      width: 1.8rem;
      height: 1.8rem;
      border-radius: .45rem;
      border: 1px solid rgba(56,189,248,.45);
      align-items: center;
      justify-content: center;
      color: var(--accent);
      font-weight: 600;
    }

    input[type="number"] {
      width: 5.5rem;
      border-radius: .45rem;
      border: 1px solid rgba(56,189,248,.35);
      background: rgba(2,8,24,.9);
      color: var(--text);
      padding: .35rem .4rem;
    }

    .btn-primary {
      align-self: flex-start;
      padding: .75rem 1.5rem;
      border-radius: .85rem;
      border: none;
      background: linear-gradient(135deg, rgba(56,189,248,.9), rgba(59,130,246,.9));
      color: white;
      font-weight: 600;
      cursor: pointer;
    }

    .results {
      display: grid;
      gap: .8rem;
      background: rgba(3,7,24,.9);
      border: 1px solid var(--border);
      border-radius: .9rem;
      padding: 1rem 1.2rem;
    }

    .metrics {
      display: grid;
      grid-template-columns: repeat(auto-fit,minmax(12rem,1fr));
      gap: .85rem;
    }

    .metric {
      border: 1px solid rgba(56,189,248,.25);
      border-radius: .6rem;
      padding: .7rem;
      background: rgba(56,189,248,.08);
    }

    .metric span { font-size: .75rem; color: var(--muted); }
    .metric strong { font-size: 1rem; }

    .empty {
      border: 1px dashed rgba(148,163,184,.4);
      border-radius: .8rem;
      padding: 1rem;
      text-align: center;
      color: var(--muted);
    }

    @media (max-width: 920px) { header, main { padding: 1.2rem; } }
  </style>
</head>
<body>
  <header>
    <h1>Image Localizator</h1>
    <p>Collega punti tra la foto e le coordinate reali sfruttando OpenStreetMap, poi stima la posa della fotocamera tramite DLT.</p>
  </header>
  <main>
    <section class="status" id="statusBanner">
      <strong>Pronto:</strong>
      <span id="statusMessage">carica una foto per iniziare.</span>
    </section>
    <section class="layout">
      <div class="panel">
        <h2>Foto di riferimento <span>(2D)</span></h2>
        <div class="upload">
          <p>Carica la foto e clicca sui punti distintivi che vuoi geolocalizzare.</p>
          <label for="imageInput">Carica immagine…</label>
          <input type="file" id="imageInput" accept="image/*" />
        </div>
        <div class="image-box" id="imageWrapper">
          <img id="photo" alt="Foto" />
          <canvas id="photoOverlay"></canvas>
          <div class="placeholder" id="photoPlaceholder">Nessuna immagine ancora.</div>
        </div>
        <div class="controls">
          <button id="clearImagePoints">Cancella punti</button>
          <button id="fitImage">Adatta immagine</button>
        </div>
      </div>
      <div class="panel">
        <h2>Mappa OpenStreetMap <span>(coordinate reali)</span></h2>
        <div id="map"></div>
        <div class="notice">Clicca per agganciare il punto selezionato sulla foto. L'altitudine predefinita è 0 m ed è modificabile dalla tabella.</div>
        <div class="controls">
          <button id="zoomIn">Zoom +</button>
          <button id="zoomOut">Zoom -</button>
          <button id="resetView">Reset vista</button>
        </div>
      </div>
    </section>
    <section class="panel">
      <h2>Associazioni 2D ↔ 3D</h2>
      <div class="empty" id="emptyState">Servono almeno 6 corrispondenze per stimare la posa.</div>
      <table id="matchesTable" style="display:none;">
        <thead>
          <tr>
            <th>#</th>
            <th>Punto foto (px)</th>
            <th>Coord. mappa</th>
            <th>Altitudine (m)</th>
            <th>Azioni</th>
          </tr>
        </thead>
        <tbody id="matchesBody"></tbody>
      </table>
      <button class="btn-primary" id="solveButton">Calcola posa fotocamera</button>
      <div class="results" id="resultsCard" style="display:none;">
        <h3>Risultati stimati</h3>
        <div class="metrics">
          <div class="metric"><span>Latitudine</span><strong id="resultLat">-</strong></div>
          <div class="metric"><span>Longitudine</span><strong id="resultLng">-</strong></div>
          <div class="metric"><span>Altitudine</span><strong id="resultAlt">-</strong></div>
          <div class="metric"><span>Heading</span><strong id="resultHeading">-</strong></div>
          <div class="metric"><span>Tilt</span><strong id="resultTilt">-</strong></div>
          <div class="metric"><span>Errore medio</span><strong id="resultReproj">-</strong></div>
        </div>
      </div>
    </section>
  </main>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-o9N1j+rWnJf6VnGaGL3+rXhN3kLBXjg5eQvM/vy6m0A=" crossorigin="" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/ml-matrix@6.10.4/matrix.umd.js" defer></script>
  <script defer>
    const ImageLocalizatorApp = (() => {
      const state = {
        correspondences: [],
        nextId: 1,
        pending: null,
        image: {
          element: null,
          overlay: null,
          ctx: null,
          naturalWidth: 0,
          naturalHeight: 0,
        },
        map: {
          instance: null,
          markers: null,
          defaultView: { center: [48.85837, 2.29448], zoom: 18 },
        },
      };

      const dom = {};

      function cacheDom() {
        dom.imageInput = document.getElementById('imageInput');
        dom.imageWrapper = document.getElementById('imageWrapper');
        dom.photo = document.getElementById('photo');
        dom.overlay = document.getElementById('photoOverlay');
        dom.placeholder = document.getElementById('photoPlaceholder');
        dom.clear = document.getElementById('clearImagePoints');
        dom.fit = document.getElementById('fitImage');
        dom.statusBanner = document.getElementById('statusBanner');
        dom.statusMessage = document.getElementById('statusMessage');
        dom.matchesTable = document.getElementById('matchesTable');
        dom.matchesBody = document.getElementById('matchesBody');
        dom.emptyState = document.getElementById('emptyState');
        dom.solve = document.getElementById('solveButton');
        dom.resultsCard = document.getElementById('resultsCard');
        dom.resultLat = document.getElementById('resultLat');
        dom.resultLng = document.getElementById('resultLng');
        dom.resultAlt = document.getElementById('resultAlt');
        dom.resultHeading = document.getElementById('resultHeading');
        dom.resultTilt = document.getElementById('resultTilt');
        dom.resultReproj = document.getElementById('resultReproj');
        dom.zoomIn = document.getElementById('zoomIn');
        dom.zoomOut = document.getElementById('zoomOut');
        dom.resetView = document.getElementById('resetView');
      }

      function init() {
        if (!window.mlMatrix || !window.L) {
          alert('Librerie necessarie non disponibili.');
          return;
        }

        cacheDom();
        state.image.element = dom.photo;
        state.image.overlay = dom.overlay;
        state.image.ctx = dom.overlay.getContext('2d');

        dom.imageInput.addEventListener('change', handleImageSelection);
        dom.imageWrapper.addEventListener('click', handleImageClick);
        dom.clear.addEventListener('click', clearPoints);
        dom.fit.addEventListener('click', () => fitImage(true));
        dom.matchesBody.addEventListener('click', handleTableClick);
        dom.matchesBody.addEventListener('input', handleTableChange);
        dom.solve.addEventListener('click', computePose);
        dom.zoomIn.addEventListener('click', () => adjustZoom(1));
        dom.zoomOut.addEventListener('click', () => adjustZoom(-1));
        dom.resetView.addEventListener('click', resetView);
        window.addEventListener('resize', syncOverlaySize);

        state.image.element.addEventListener('load', () => {
          state.image.naturalWidth = state.image.element.naturalWidth;
          state.image.naturalHeight = state.image.element.naturalHeight;
          dom.placeholder.style.display = 'none';
          state.image.element.style.display = 'block';
          syncOverlaySize();
          drawOverlay();
          pushStatus('Immagine caricata. Seleziona un punto.', false);
        });

        initMap();
      }

      function initMap() {
        state.map.instance = L.map('map', { zoomControl: false })
          .setView(state.map.defaultView.center, state.map.defaultView.zoom);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 20,
          attribution: '&copy; OpenStreetMap contributors',
        }).addTo(state.map.instance);
        L.control.zoom({ position: 'bottomright' }).addTo(state.map.instance);
        state.map.markers = L.layerGroup().addTo(state.map.instance);
        state.map.instance.on('click', (event) => {
          if (event.latlng) handleMapClick(event.latlng);
        });
        pushStatus('Mappa OSM pronta. Clicca sulla foto, poi sulla mappa.', false);
      }

      function handleImageSelection(event) {
        const file = event.target.files?.[0];
        if (!file) return;
        state.image.element.src = URL.createObjectURL(file);
        clearPoints();
        dom.resultsCard.style.display = 'none';
      }

      function handleImageClick(event) {
        if (!state.image.naturalWidth) return;
        const rect = state.image.element.getBoundingClientRect();
        if (
          event.clientX < rect.left || event.clientX > rect.right ||
          event.clientY < rect.top || event.clientY > rect.bottom
        ) return;
        const relX = (event.clientX - rect.left) / rect.width;
        const relY = (event.clientY - rect.top) / rect.height;
        const imagePoint = {
          x: relX * state.image.naturalWidth,
          y: relY * state.image.naturalHeight,
        };
        const id = state.nextId++;
        const entry = { id, imagePoint, mapPoint: null, marker: null };
        state.correspondences.push(entry);
        state.pending = { id };
        updateTable();
        drawOverlay();
        highlightPending(id);
        pushStatus(Punto # selezionato. Ora clicca sulla mappa., false);
      }

      function handleMapClick(latlng) {
        if (!state.pending) {
          pushStatus('Seleziona prima un punto sulla foto.', true);
          return;
        }
        const entry = state.correspondences.find((item) => item.id === state.pending.id);
        if (!entry) {
          state.pending = null;
          return;
        }
        if (entry.marker) state.map.markers.removeLayer(entry.marker);
        const altitude = entry.mapPoint?.altitude ?? 0;
        entry.mapPoint = {
          lat: latlng.lat,
          lng: latlng.lng,
          altitude,
          ecef: latLngAltToECEF(latlng.lat, latlng.lng, altitude),
        };
        entry.marker = L.marker(latlng, { draggable: true }).addTo(state.map.markers);
        entry.marker.bindTooltip(#, { permanent: true, offset: [0, -12] });
        entry.marker.on('dragend', (event) => {
          const pos = event.target.getLatLng();
          entry.mapPoint.lat = pos.lat;
          entry.mapPoint.lng = pos.lng;
          entry.mapPoint.ecef = latLngAltToECEF(pos.lat, pos.lng, entry.mapPoint.altitude ?? 0);
          updateTable();
        });
        state.pending = null;
        updateTable();
        drawOverlay();
        pushStatus(Punto # collegato., false);
      }

      function clearPoints() {
        state.correspondences.forEach((entry) => {
          if (entry.marker) state.map.markers.removeLayer(entry.marker);
        });
        state.correspondences = [];
        state.pending = null;
        state.nextId = 1;
        updateTable();
        drawOverlay();
        pushStatus('Punti rimossi.', false);
      }

      function fitImage(notify) {
        if (!state.image.naturalWidth) return;
        state.image.element.style.width = '100%';
        state.image.element.style.height = 'auto';
        syncOverlaySize();
        if (notify) pushStatus('Immagine adattata.', false);
      }

      function syncOverlaySize() {
        if (!state.image.naturalWidth) return;
        const rect = state.image.element.getBoundingClientRect();
        state.image.overlay.width = rect.width;
        state.image.overlay.height = rect.height;
        state.image.overlay.style.width = ${rect.width}px;
        state.image.overlay.style.height = ${rect.height}px;
        drawOverlay();
      }

      function drawOverlay() {
        const ctx = state.image.ctx;
        if (!ctx) return;
        ctx.clearRect(0, 0, state.image.overlay.width, state.image.overlay.height);
        ctx.lineWidth = 2;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        state.correspondences.forEach((entry) => {
          const { imagePoint } = entry;
          if (!imagePoint) return;
          const coords = toDisplay(imagePoint);
          const pending = state.pending?.id === entry.id;
          ctx.fillStyle = pending ? '#f97316' : '#38bdf8';
          ctx.strokeStyle = 'rgba(0,0,0,.4)';
          ctx.beginPath();
          ctx.arc(coords.x, coords.y, 7, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = '#04122e';
          ctx.font = '600 11px "Segoe UI"';
          ctx.fillText(entry.id, coords.x, coords.y + 0.5);
        });
      }

      function toDisplay(point) {
        const rect = state.image.element.getBoundingClientRect();
        return {
          x: point.x * (rect.width / state.image.naturalWidth),
          y: point.y * (rect.height / state.image.naturalHeight),
        };
      }

      function updateTable() {
        dom.matchesBody.innerHTML = '';
        if (!state.correspondences.length) {
          dom.matchesTable.style.display = 'none';
          dom.emptyState.style.display = 'block';
          return;
        }
        dom.matchesTable.style.display = 'table';
        dom.emptyState.style.display = 'none';
        state.correspondences.forEach((entry) => {
          const tr = document.createElement('tr');
          tr.dataset.id = entry.id;
          const coords = entry.mapPoint
            ? <div>Lat: </div><div>Lng: </div>
            : '<div class="secondary">Clicca sulla mappa</div>';
          const altitude = entry.mapPoint?.altitude ?? '';
          tr.innerHTML = 
            <td><span class="badge"></span></td>
            <td>, </td>
            <td></td>
            <td><input type="number" class="altitude-input" data-id="" value=""></td>
            <td><button data-action="remove" data-id="">Rimuovi</button></td>
          ;
          dom.matchesBody.appendChild(tr);
        });
        if (state.pending) highlightPending(state.pending.id);
      }

      function highlightPending(id) {
        dom.matchesBody.querySelectorAll('tr').forEach((row) => {
          row.style.background = Number(row.dataset.id) === id ? 'rgba(249,115,22,.18)' : '';
        });
      }

      function handleTableClick(event) {
        const target = event.target;
        if (!(target instanceof HTMLElement)) return;
        if (target.dataset.action === 'remove') {
          removeCorrespondence(Number(target.dataset.id));
        }
      }

      function handleTableChange(event) {
        const target = event.target;
        if (!(target instanceof HTMLInputElement)) return;
        if (!target.classList.contains('altitude-input')) return;
        const id = Number(target.dataset.id);
        const value = Number(target.value);
        if (Number.isNaN(value)) return;
        const entry = state.correspondences.find((item) => item.id === id);
        if (entry && entry.mapPoint) {
          entry.mapPoint.altitude = value;
          entry.mapPoint.ecef = latLngAltToECEF(entry.mapPoint.lat, entry.mapPoint.lng, value);
        }
      }

      function removeCorrespondence(id) {
        const index = state.correspondences.findIndex((entry) => entry.id === id);
        if (index === -1) return;
        const [removed] = state.correspondences.splice(index, 1);
        if (removed?.marker) state.map.markers.removeLayer(removed.marker);
        if (state.pending?.id === id) state.pending = null;
        updateTable();
        drawOverlay();
        pushStatus(Corrispondenza # rimossa., false);
      }

      function pushStatus(message, isError = false) {
        dom.statusBanner.style.background = isError
          ? 'rgba(244,63,94,.18)'
          : 'rgba(56,189,248,.15)';
        dom.statusBanner.style.borderColor = isError
          ? 'rgba(244,63,94,.4)'
          : 'rgba(56,189,248,.35)';
        dom.statusMessage.textContent = message;
      }

      function adjustZoom(delta) {
        if (!state.map.instance) return;
        state.map.instance.setZoom(state.map.instance.getZoom() + delta);
      }

      function resetView() {
        if (!state.map.instance) return;
        state.map.instance.setView(state.map.defaultView.center, state.map.defaultView.zoom);
      }

      function computePose() {
        const usable = state.correspondences.filter((entry) => entry.imagePoint && entry.mapPoint?.ecef);
        if (usable.length < 6) {
          pushStatus('Servono almeno 6 corrispondenze complete.', true);
          return;
        }
        try {
          const { Matrix, SVD } = window.mlMatrix;
          const Adata = [];
          usable.forEach((entry) => {
            const { x, y } = entry.imagePoint;
            const { x: X, y: Y, z: Z } = entry.mapPoint.ecef;
            Adata.push([X, Y, Z, 1, 0, 0, 0, 0, -x * X, -x * Y, -x * Z, -x]);
            Adata.push([0, 0, 0, 0, X, Y, Z, 1, -y * X, -y * Y, -y * Z, -y]);
          });
          const A = new Matrix(Adata);
          const svd = new SVD(A);
          const V = svd.rightSingularVectors;
          const h = V.getColumn(V.columns - 1);
          const P = Matrix.from1DArray(3, 4, h);
          const M = P.subMatrix(0, 2, 0, 2);
          const p4 = P.subMatrix(0, 2, 3, 3);
          const Minv = invert3x3(M, Matrix);
          const c = Minv.mmul(p4);
          const cameraECEF = { x: -c.get(0, 0), y: -c.get(1, 0), z: -c.get(2, 0) };
          const geo = ecefToGeodetic(cameraECEF.x, cameraECEF.y, cameraECEF.z);
          dom.resultLat.textContent = ${geo.lat.toFixed(6)}°;
          dom.resultLng.textContent = ${geo.lng.toFixed(6)}°;
          dom.resultAlt.textContent = ${geo.altitude.toFixed(2)} m;
          try {
            const { R } = decomposeKR(M, Matrix);
            const forward = cameraForwardVector(R);
            const { heading, tilt } = computeViewAngles(forward, cameraECEF);
            dom.resultHeading.textContent = ${heading.toFixed(1)}°;
            dom.resultTilt.textContent = ${tilt.toFixed(1)}°;
          } catch (orientationError) {
            dom.resultHeading.textContent = 'n/d';
            dom.resultTilt.textContent = 'n/d';
          }
          const reprojectionError = computeReprojectionError(P, usable);
          dom.resultReproj.textContent = ${reprojectionError.toFixed(2)} px;
          dom.resultsCard.style.display = 'grid';
          pushStatus('Posa stimata. Verifica i risultati.', false);
        } catch (error) {
          console.error(error);
          pushStatus('Errore nel calcolo della posa.', true);
        }
      }

      function computeReprojectionError(P, correspondences) {
        const { Matrix } = window.mlMatrix;
        let total = 0;
        let count = 0;
        correspondences.forEach((entry) => {
          const world = entry.mapPoint.ecef;
          const point = Matrix.columnVector([world.x, world.y, world.z, 1]);
          const projected = P.mmul(point);
          const w = projected.get(2, 0);
          if (Math.abs(w) < 1e-9) return;
          const x = projected.get(0, 0) / w;
          const y = projected.get(1, 0) / w;
          total += Math.hypot(x - entry.imagePoint.x, y - entry.imagePoint.y);
          count += 1;
        });
        return count ? total / count : 0;
      }

      function decomposeKR(M, Matrix) {
        const J = new Matrix([[0, 0, 1],[0, 1, 0],[1, 0, 0]]);
        const QR = new window.mlMatrix.QRDecomposition(J.mmul(M.transpose()));
        let R = QR.QR.transpose().mmul(J);
        let K = J.mmul(QR.R.transpose()).mmul(J);
        const diag = [K.get(0,0), K.get(1,1), K.get(2,2)].map((d) => (d < 0 ? -1 : 1));
        const signMatrix = Matrix.diag(diag);
        K = K.mmul(signMatrix);
        R = signMatrix.mmul(R);
        const scale = K.get(2, 2);
        if (scale !== 0) K = K.mul(1 / scale);
        if (R.det() < 0) {
          R = R.mul(-1);
          K = K.mul(-1);
        }
        return { K, R };
      }

      function cameraForwardVector(R) {
        const Rt = R.transpose();
        const forward = { x: Rt.get(0, 2), y: Rt.get(1, 2), z: Rt.get(2, 2) };
        const norm = Math.sqrt(forward.x ** 2 + forward.y ** 2 + forward.z ** 2) || 1;
        return { x: forward.x / norm, y: forward.y / norm, z: forward.z / norm };
      }

      function computeViewAngles(forward, cameraECEF) {
        const geo = ecefToGeodetic(cameraECEF.x, cameraECEF.y, cameraECEF.z);
        const enu = ecefVectorToENU(forward, geo.lat, geo.lng);
        const heading = (Math.atan2(enu.east, enu.north) * 180 / Math.PI + 360) % 360;
        const horizontal = Math.sqrt(enu.east ** 2 + enu.north ** 2);
        const pitch = Math.atan2(enu.up, horizontal) * 180 / Math.PI;
        const tilt = Math.max(0, Math.min(90, 90 - pitch));
        return { heading, tilt };
      }

      function ecefVectorToENU(vector, latDeg, lonDeg) {
        const lat = degToRad(latDeg);
        const lon = degToRad(lonDeg);
        const sinLat = Math.sin(lat);
        const cosLat = Math.cos(lat);
        const sinLon = Math.sin(lon);
        const cosLon = Math.cos(lon);
        const east = -sinLon * vector.x + cosLon * vector.y;
        const north = -sinLat * cosLon * vector.x - sinLat * sinLon * vector.y + cosLat * vector.z;
        const up = cosLat * cosLon * vector.x + cosLat * sinLon * vector.y + sinLat * vector.z;
        return { east, north, up };
      }

      function latLngAltToECEF(latDeg, lonDeg, altitude) {
        const a = 6378137.0;
        const e2 = 6.69437999014e-3;
        const lat = degToRad(latDeg);
        const lon = degToRad(lonDeg);
        const cosLat = Math.cos(lat);
        const sinLat = Math.sin(lat);
        const cosLon = Math.cos(lon);
        const sinLon = Math.sin(lon);
        const N = a / Math.sqrt(1 - e2 * sinLat * sinLat);
        const x = (N + altitude) * cosLat * cosLon;
        const y = (N + altitude) * cosLat * sinLon;
        const z = (N * (1 - e2) + altitude) * sinLat;
        return { x, y, z };
      }

      function ecefToGeodetic(x, y, z) {
        const a = 6378137.0;
        const e2 = 6.69437999014e-3;
        const b = a * Math.sqrt(1 - e2);
        const ep2 = (a * a - b * b) / (b * b);
        const p = Math.sqrt(x * x + y * y);
        const theta = Math.atan2(z * a, p * b);
        const sinTheta = Math.sin(theta);
        const cosTheta = Math.cos(theta);
        const lat = Math.atan2(z + ep2 * b * sinTheta ** 3, p - e2 * a * cosTheta ** 3);
        const lon = Math.atan2(y, x);
        const sinLat = Math.sin(lat);
        const N = a / Math.sqrt(1 - e2 * sinLat * sinLat);
        const alt = p / Math.cos(lat) - N;
        return { lat: radToDeg(lat), lng: radToDeg(lon), altitude: alt };
      }

      function invert3x3(M, Matrix) {
        const m = M.to2DArray();
        const [[a, b, c], [d, e, f], [g, h, i]] = m;
        const det = a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);
        if (Math.abs(det) < 1e-9) throw new Error('Matrice non invertibile');
        const inv = [
          [(e * i - f * h) / det, (c * h - b * i) / det, (b * f - c * e) / det],
          [(f * g - d * i) / det, (a * i - c * g) / det, (c * d - a * f) / det],
          [(d * h - e * g) / det, (b * g - a * h) / det, (a * e - b * d) / det],
        ];
        return new Matrix(inv);
      }

      function degToRad(value) { return value * Math.PI / 180; }
      function radToDeg(value) { return value * 180 / Math.PI; }

      return { init };
    })();

    document.addEventListener('DOMContentLoaded', () => ImageLocalizatorApp.init());
  </script>
</body>
</html>
