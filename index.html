<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Localizator</title>
    <style>
        :root {
            color-scheme: dark;
            --bg: #0f172a;
            --bg-panel: #111c3a;
            --bg-muted: #1e293b;
            --accent: #38bdf8;
            --warning: #f97316;
            --danger: #f43f5e;
            --text: #f8fafc;
            --text-muted: #cbd5f5;
            --border: #24345a;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: "Segoe UI", sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            padding: 1.25rem 2rem;
            background: rgba(15, 23, 42, 0.9);
            border-bottom: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
        }

        header h1 {
            margin: 0;
            font-size: 1.5rem;
            letter-spacing: 0.05em;
        }

        header p {
            margin: 0;
            color: var(--text-muted);
            max-width: 64rem;
        }

        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 1.5rem 2rem 2.5rem;
            gap: 1.5rem;
        }

        .panels {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
        }

        .panel {
            flex: 1 1 28rem;
            display: flex;
            flex-direction: column;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 1rem;
            padding: 1.25rem;
            gap: 1rem;
            box-shadow: 0 8px 30px rgba(8, 25, 60, 0.35);
        }

        .panel h2 {
            margin: 0;
            font-size: 1.1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .panel h2 span {
            font-size: 0.85rem;
            font-weight: 400;
            color: var(--text-muted);
        }

        .upload-area {
            border: 1px dashed var(--border);
            border-radius: 0.75rem;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.75rem;
            background: rgba(30, 41, 59, 0.45);
        }

        .upload-area input[type="file"] {
            display: none;
        }

        .upload-area label {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.6rem 1.4rem;
            border-radius: 999px;
            border: 1px solid rgba(56, 189, 248, 0.4);
            color: var(--accent);
            cursor: pointer;
            transition: background 0.2s ease, border-color 0.2s ease;
        }

        .upload-area label:hover {
            background: rgba(56, 189, 248, 0.1);
            border-color: var(--accent);
        }

        .image-container {
            position: relative;
            width: 100%;
            background: #0b1120;
            border-radius: 0.75rem;
            border: 1px solid var(--border);
            min-height: 22rem;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .image-container img {
            max-width: 100%;
            max-height: 32rem;
            display: none;
        }

        .image-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        .placeholder {
            color: var(--text-muted);
            text-align: center;
            padding: 2rem;
            max-width: 20rem;
            line-height: 1.5;
        }

        .map-container {
            position: relative;
            width: 100%;
            height: 32rem;
            border-radius: 0.75rem;
            border: 1px solid var(--border);
            overflow: hidden;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .legend {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .legend span {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
        }

        .legend .dot {
            width: 0.75rem;
            height: 0.75rem;
            border-radius: 999px;
            display: inline-block;
        }

        .dot.image {
            background: var(--accent);
        }

        .dot.pending {
            background: var(--warning);
        }

        .controls-row {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
        }

        .controls-row button {
            border: none;
            border-radius: 0.6rem;
            padding: 0.6rem 1rem;
            background: rgba(56, 189, 248, 0.18);
            color: var(--accent);
            font-size: 0.9rem;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .controls-row button:hover {
            background: rgba(56, 189, 248, 0.3);
        }

        .badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 1.75rem;
            height: 1.75rem;
            border-radius: 0.5rem;
            background: rgba(56, 189, 248, 0.12);
            border: 1px solid rgba(56, 189, 248, 0.4);
            color: var(--accent);
            font-size: 0.85rem;
            font-weight: 600;
        }

        .data-panel {
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 1rem;
            padding: 1.25rem;
            box-shadow: 0 8px 30px rgba(8, 25, 60, 0.35);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            border: 1px solid var(--border);
            border-radius: 0.6rem;
            overflow: hidden;
        }

        thead {
            background: rgba(30, 41, 59, 0.8);
        }

        th, td {
            padding: 0.65rem 0.85rem;
            text-align: left;
            border-bottom: 1px solid rgba(36, 52, 90, 0.6);
            font-size: 0.85rem;
        }

        tbody tr:hover {
            background: rgba(56, 189, 248, 0.06);
        }

        tbody tr:last-child td {
            border-bottom: none;
        }

        .pending-map {
            background: rgba(249, 115, 22, 0.15) !important;
        }

        .table-actions button {
            padding: 0.35rem 0.6rem;
            border-radius: 0.5rem;
            border: 1px solid rgba(244, 63, 94, 0.4);
            background: rgba(244, 63, 94, 0.12);
            color: var(--danger);
            font-size: 0.75rem;
            cursor: pointer;
        }

        .table-actions button:hover {
            background: rgba(244, 63, 94, 0.25);
        }

        .status-banner {
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            background: rgba(56, 189, 248, 0.12);
            border: 1px solid rgba(56, 189, 248, 0.4);
            color: var(--text);
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .status-banner strong {
            color: var(--accent);
        }

        .secondary {
            color: var(--text-muted);
            font-size: 0.8rem;
        }

        .notice {
            background: rgba(249, 115, 22, 0.15);
            border: 1px solid rgba(249, 115, 22, 0.4);
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            font-size: 0.8rem;
            line-height: 1.4;
            color: #fcd34d;
        }

        input[type="number"] {
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(56, 189, 248, 0.25);
            border-radius: 0.5rem;
            padding: 0.4rem 0.6rem;
            color: var(--text);
            width: 6rem;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.2);
        }

        .btn-primary {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            border: none;
            background: linear-gradient(135deg, rgba(56, 189, 248, 0.85), rgba(59, 130, 246, 0.85));
            color: var(--text);
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            align-self: flex-start;
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 25px rgba(56, 189, 248, 0.2);
        }

        .results-card {
            display: grid;
            gap: 0.75rem;
            background: rgba(15, 23, 42, 0.9);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            padding: 1rem 1.25rem;
        }

        .results-card h3 {
            margin: 0;
            font-size: 1rem;
            color: var(--accent);
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(12rem, 1fr));
            gap: 0.85rem;
        }

        .metric {
            padding: 0.75rem;
            border-radius: 0.6rem;
            background: rgba(56, 189, 248, 0.08);
            border: 1px solid rgba(56, 189, 248, 0.2);
            display: grid;
            gap: 0.35rem;
        }

        .metric span {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .metric strong {
            font-size: 0.95rem;
            letter-spacing: 0.02em;
        }

        .empty-state {
            padding: 1rem;
            border-radius: 0.75rem;
            border: 1px dashed rgba(148, 163, 184, 0.35);
            color: var(--text-muted);
            text-align: center;
        }

        @media (max-width: 960px) {
            header {
                padding: 1.1rem 1.5rem;
            }

            main {
                padding: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Image Localizator</h1>
        <p>
            Carica un'immagine, allinea punti corrispondenti fra foto e mappa satellitare 3D e calcola una posa approssimata della fotocamera.
            Configura un file <code>.env</code> con <code>GOOGLE_MAPS_API_KEY=</code> per abilitare il caricamento della mappa.
        </p>
    </header>

    <main>
        <section class="status-banner" id="statusBanner">
            <strong>Pronto:</strong>
            <span id="statusMessage">carica una foto e fai clic per iniziare a creare corrispondenze 2D ↔ 3D.</span>
        </section>

        <section class="panels">
            <div class="panel image-panel">
                <h2>Foto di riferimento <span>(2D)</span></h2>
                <div class="upload-area">
                    <label for="imageInput">Carica immagine...</label>
                    <input type="file" id="imageInput" accept="image/*">
                    <div class="notice">
                        Clicca su punti ben riconoscibili della foto. Per ognuno dovrai aggiungere il punto corrispondente sulla mappa.
                    </div>
                </div>
                <div class="legend">
                    <span><span class="dot image"></span> Punto collegato</span>
                    <span><span class="dot pending"></span> In attesa del punto mappa</span>
                </div>
                <div class="image-container" id="imageWrapper">
                    <img id="photo" alt="Foto di riferimento">
                    <canvas id="photoOverlay"></canvas>
                    <div class="placeholder" id="photoPlaceholder">
                        Carica un'immagine dell'area da localizzare. Clicca sulla foto per aggiungere i punti di riferimento.
                    </div>
                </div>
                <div class="controls-row">
                    <button id="clearImagePoints">Cancella punti foto</button>
                    <button id="fitImage">Adatta immagine</button>
                </div>
            </div>

            <div class="panel map-panel">
                <h2>Mappa satellitare <span>(3D)</span></h2>
                <div class="map-container" id="mapContainer">
                    <div id="map"></div>
                </div>
                <div class="notice">
                    Dopo aver cliccato sulla foto, posiziona qui il punto corrispondente. I marker sono trascinabili; puoi aggiornare manualmente l'altitudine in tabella.
                </div>
                <div class="controls-row">
                    <button id="tiltIncrease">Aumenta tilt</button>
                    <button id="tiltDecrease">Riduci tilt</button>
                    <button id="headingLeft">Ruota sinistra</button>
                    <button id="headingRight">Ruota destra</button>
                    <button id="resetView">Reset vista</button>
                </div>
            </div>
        </section>

        <section class="data-panel">
            <h2>Associazioni 2D ↔ 3D</h2>
            <div class="empty-state" id="emptyState">
                Servono almeno 6 corrispondenze complete per stimare la posizione della telecamera.
            </div>
            <table id="matchesTable" style="display:none;">
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Punto foto (px)</th>
                        <th>Punto mappa</th>
                        <th>Altitudine (m)</th>
                        <th>Azioni</th>
                    </tr>
                </thead>
                <tbody id="matchesBody"></tbody>
            </table>
            <button class="btn-primary" id="solveButton">Calcola posa fotocamera</button>
            <div class="results-card" id="resultsCard" style="display:none;">
                <h3>Risultati stimati</h3>
                <div class="results-grid">
                    <div class="metric">
                        <span>Latitudine</span>
                        <strong id="resultLat">-</strong>
                    </div>
                    <div class="metric">
                        <span>Longitudine</span>
                        <strong id="resultLng">-</strong>
                    </div>
                    <div class="metric">
                        <span>Altitudine</span>
                        <strong id="resultAlt">-</strong>
                    </div>
                    <div class="metric">
                        <span>Heading stimato</span>
                        <strong id="resultHeading">-</strong>
                    </div>
                    <div class="metric">
                        <span>Tilt stimato</span>
                        <strong id="resultTilt">-</strong>
                    </div>
                    <div class="metric">
                        <span>Errore medio di reproiezione</span>
                        <strong id="resultReproj">-</strong>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/ml-matrix@6.10.4/matrix.umd.js" defer></script>
    <script>
        const ImageLocalizatorApp = (() => {
            'use strict';

            const state = {
                correspondences: [],
                nextId: 1,
                pending: null,
                image: {
                    element: null,
                    overlay: null,
                    overlayCtx: null,
                    naturalWidth: 0,
                    naturalHeight: 0
                },
                map: {
                    instance: null,
                    tilt: 60,
                    heading: 0,
                    elevationService: null
                },
                config: {
                    envLoaded: false,
                    mapsKey: null,
                    mapId: null
                }
            };

            const dom = {};

            function cacheDom() {
                dom.imageInput = document.getElementById('imageInput');
                dom.imageWrapper = document.getElementById('imageWrapper');
                dom.photo = document.getElementById('photo');
                dom.overlay = document.getElementById('photoOverlay');
                dom.placeholder = document.getElementById('photoPlaceholder');
                dom.clearImagePoints = document.getElementById('clearImagePoints');
                dom.fitImage = document.getElementById('fitImage');
                dom.statusBanner = document.getElementById('statusBanner');
                dom.statusMessage = document.getElementById('statusMessage');
                dom.matchesTable = document.getElementById('matchesTable');
                dom.matchesBody = document.getElementById('matchesBody');
                dom.emptyState = document.getElementById('emptyState');
                dom.solveButton = document.getElementById('solveButton');
                dom.resultsCard = document.getElementById('resultsCard');
                dom.resultLat = document.getElementById('resultLat');
                dom.resultLng = document.getElementById('resultLng');
                dom.resultAlt = document.getElementById('resultAlt');
                dom.resultHeading = document.getElementById('resultHeading');
                dom.resultTilt = document.getElementById('resultTilt');
                dom.resultReproj = document.getElementById('resultReproj');
                dom.tiltIncrease = document.getElementById('tiltIncrease');
                dom.tiltDecrease = document.getElementById('tiltDecrease');
                dom.headingLeft = document.getElementById('headingLeft');
                dom.headingRight = document.getElementById('headingRight');
                dom.resetView = document.getElementById('resetView');
            }

            function init() {
                if (!window.mlMatrix) {
                    pushStatus('Impossibile caricare la libreria ml-matrix. Controlla la connessione e ricarica.', true);
                    return;
                }

                cacheDom();
                state.image.element = dom.photo;
                state.image.overlay = dom.overlay;
                state.image.overlayCtx = dom.overlay.getContext('2d');

                dom.imageInput.addEventListener('change', handleImageSelection);
                dom.imageWrapper.addEventListener('click', handleImageClick);
                dom.clearImagePoints.addEventListener('click', clearImagePoints);
                dom.fitImage.addEventListener('click', () => fitImageToContainer(true));
                dom.matchesBody.addEventListener('click', handleTableClick);
                dom.matchesBody.addEventListener('change', handleTableChange);
                dom.solveButton.addEventListener('click', computeCameraPose);
                dom.tiltIncrease.addEventListener('click', () => adjustTilt(5));
                dom.tiltDecrease.addEventListener('click', () => adjustTilt(-5));
                dom.headingLeft.addEventListener('click', () => adjustHeading(-10));
                dom.headingRight.addEventListener('click', () => adjustHeading(10));
                dom.resetView.addEventListener('click', resetMapView);
                window.addEventListener('resize', syncOverlaySize);

                state.image.element.addEventListener('load', () => {
                    state.image.naturalWidth = state.image.element.naturalWidth;
                    state.image.naturalHeight = state.image.element.naturalHeight;
                    dom.placeholder.style.display = 'none';
                    state.image.element.style.display = 'block';
                    syncOverlaySize();
                    drawOverlay();
                    pushStatus('Immagine caricata. Clicca su un punto della foto per iniziare una corrispondenza.', false);
                });
            }

            function handleImageSelection(event) {
                const file = event.target.files?.[0];
                if (!file) {
                    return;
                }
                const url = URL.createObjectURL(file);
                state.image.element.src = url;
                state.correspondences = [];
                state.nextId = 1;
                state.pending = null;
                updateTable();
                drawOverlay();
                dom.resultsCard.style.display = 'none';
            }

            function handleImageClick(event) {
                if (!state.image.naturalWidth || !state.image.naturalHeight) {
                    return;
                }
                const rect = state.image.element.getBoundingClientRect();
                if (event.clientX < rect.left || event.clientX > rect.right || event.clientY < rect.top || event.clientY > rect.bottom) {
                    return;
                }

                const relativeX = (event.clientX - rect.left) / rect.width;
                const relativeY = (event.clientY - rect.top) / rect.height;

                const xPx = relativeX * state.image.naturalWidth;
                const yPx = relativeY * state.image.naturalHeight;

                const id = state.nextId++;
                const entry = {
                    id,
                    imagePoint: { x: xPx, y: yPx },
                    mapPoint: null,
                    marker: null
                };
                state.correspondences.push(entry);
                state.pending = { type: 'map', id };
                updateTable();
                drawOverlay();
                highlightPending(entry.id);
                pushStatus(`Punto #${id} aggiunto sulla foto. Ora clicca sulla mappa per posizionare la corrispondenza.`, false);
            }

            function highlightPending(id) {
                if (!dom.matchesBody) {
                    return;
                }
                dom.matchesBody.querySelectorAll('tr').forEach((row) => {
                    if (Number(row.dataset.id) === id) {
                        row.classList.add('pending-map');
                    } else {
                        row.classList.remove('pending-map');
                    }
                });
            }

            function clearImagePoints() {
                state.correspondences.forEach((entry) => {
                    if (entry.marker) {
                        entry.marker.setMap(null);
                    }
                });
                state.correspondences = [];
                state.nextId = 1;
                state.pending = null;
                updateTable();
                drawOverlay();
                dom.resultsCard.style.display = 'none';
                pushStatus('Tutti i punti sono stati rimossi.', false);
            }

            function fitImageToContainer(notify = false) {
                if (!state.image.naturalWidth) {
                    return;
                }
                state.image.element.style.width = '100%';
                state.image.element.style.height = 'auto';
                syncOverlaySize();
                drawOverlay();
                if (notify) {
                    pushStatus('Immagine adattata al contenitore.', false);
                }
            }

            function syncOverlaySize() {
                if (!state.image.naturalWidth) {
                    return;
                }
                const rect = state.image.element.getBoundingClientRect();
                state.image.overlay.width = rect.width;
                state.image.overlay.height = rect.height;
                state.image.overlay.style.width = `${rect.width}px`;
                state.image.overlay.style.height = `${rect.height}px`;
                drawOverlay();
            }

            function drawOverlay() {
                const ctx = state.image.overlayCtx;
                if (!ctx) {
                    return;
                }
                const width = state.image.overlay.width;
                const height = state.image.overlay.height;
                ctx.clearRect(0, 0, width, height);
                ctx.lineWidth = 2;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                state.correspondences.forEach((entry) => {
                    if (!entry.imagePoint) {
                        return;
                    }
                    const { x, y } = toDisplayCoordinates(entry.imagePoint);
                    const isPending = state.pending?.id === entry.id && state.pending?.type === 'map';
                    ctx.fillStyle = isPending ? '#f97316' : '#38bdf8';
                    ctx.strokeStyle = 'rgba(15, 23, 42, 0.65)';
                    ctx.beginPath();
                    ctx.arc(x, y, 7, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    ctx.fillStyle = '#0b1120';
                    ctx.font = '600 11px "Segoe UI", sans-serif';
                    ctx.fillText(entry.id.toString(), x, y + 0.5);
                });
            }

            function toDisplayCoordinates(point) {
                const rect = state.image.element.getBoundingClientRect();
                const scaleX = rect.width / state.image.naturalWidth;
                const scaleY = rect.height / state.image.naturalHeight;
                return {
                    x: point.x * scaleX,
                    y: point.y * scaleY
                };
            }

            function updateTable() {
                if (!dom.matchesBody) {
                    return;
                }
                dom.matchesBody.innerHTML = '';
                if (!state.correspondences.length) {
                    dom.matchesTable.style.display = 'none';
                    dom.emptyState.style.display = 'block';
                    return;
                }
                dom.matchesTable.style.display = 'table';
                dom.emptyState.style.display = 'none';

                state.correspondences.forEach((entry) => {
                    const tr = document.createElement('tr');
                    tr.dataset.id = entry.id.toString();

                    const latLngContent = entry.mapPoint
                        ? `<div>Lat: ${entry.mapPoint.lat.toFixed(6)}</div><div>Lng: ${entry.mapPoint.lng.toFixed(6)}</div>`
                        : '<div class="secondary">Clicca sulla mappa</div>';

                    const altitudeValue = entry.mapPoint?.altitude != null
                        ? entry.mapPoint.altitude.toFixed(2)
                        : '';

                    tr.innerHTML = `
                        <td><span class="badge">${entry.id}</span></td>
                        <td>${entry.imagePoint.x.toFixed(1)}, ${entry.imagePoint.y.toFixed(1)}</td>
                        <td>${latLngContent}</td>
                        <td><input type="number" class="altitude-input" data-id="${entry.id}" value="${altitudeValue}" step="0.1" placeholder="Alt"></td>
                        <td class="table-actions"><button data-action="remove" data-id="${entry.id}">Rimuovi</button></td>
                    `;
                    dom.matchesBody.appendChild(tr);
                });

                if (state.pending?.type === 'map') {
                    highlightPending(state.pending.id);
                }
            }

            function handleTableClick(event) {
                const target = event.target;
                if (!(target instanceof HTMLElement)) {
                    return;
                }
                if (target.dataset.action === 'remove') {
                    const id = Number(target.dataset.id);
                    removeCorrespondence(id);
                }
            }

            function handleTableChange(event) {
                const target = event.target;
                if (!(target instanceof HTMLInputElement)) {
                    return;
                }
                if (target.classList.contains('altitude-input')) {
                    const id = Number(target.dataset.id);
                    const value = Number(target.value);
                    if (Number.isNaN(value)) {
                        return;
                    }
                    const entry = state.correspondences.find((item) => item.id === id);
                    if (entry && entry.mapPoint) {
                        entry.mapPoint.altitude = value;
                        entry.mapPoint.ecef = latLngAltToECEF(entry.mapPoint.lat, entry.mapPoint.lng, value);
                    }
                }
            }

            function removeCorrespondence(id) {
                const index = state.correspondences.findIndex((entry) => entry.id === id);
                if (index === -1) {
                    return;
                }
                const [removed] = state.correspondences.splice(index, 1);
                if (removed?.marker) {
                    removed.marker.setMap(null);
                }
                if (state.pending?.id === id) {
                    state.pending = null;
                }
                updateTable();
                drawOverlay();
                pushStatus(`Corrispondenza #${id} rimossa.`, false);
            }

            function pushStatus(message, isError = false) {
                if (!dom.statusBanner || !dom.statusMessage) {
                    try {
                        cacheDom();
                    } catch (error) {
                        console.warn('UI non ancora pronto per aggiornare lo stato:', message);
                        return;
                    }
                }
                if (!dom.statusBanner || !dom.statusMessage) {
                    console.warn('UI non ancora pronto per aggiornare lo stato:', message);
                    return;
                }
                dom.statusBanner.style.background = isError
                    ? 'rgba(244, 63, 94, 0.18)'
                    : 'rgba(56, 189, 248, 0.12)';
                dom.statusBanner.style.borderColor = isError
                    ? 'rgba(244, 63, 94, 0.4)'
                    : 'rgba(56, 189, 248, 0.4)';
                dom.statusMessage.textContent = message;
            }

            async function loadMapsApiFromEnv() {
                if (state.config.mapsKey) {
                    ensureGoogleMapsScript(state.config.mapsKey);
                    return;
                }
                try {
                    const envContent = await readEnvFile();
                    const env = parseEnv(envContent);
                    const apiKeyRaw = env.GOOGLE_MAPS_API_KEY || env.GOOGLE_MAPS_KEY || '';
                    const apiKey = apiKeyRaw.trim();
                    if (!apiKey) {
                        pushStatus('Chiave Google Maps non trovata nel file .env. Copia .env.example e inserisci la tua API key.', true);
                        return;
                    }
                    state.config.mapsKey = apiKey;
                    const mapId = (env.GOOGLE_MAPS_MAP_ID || env.GOOGLE_MAP_ID || '').trim();
                    if (mapId) {
                        state.config.mapId = mapId;
                    }
                    state.config.envLoaded = true;
                    ensureGoogleMapsScript(apiKey);
                } catch (error) {
                    console.error(error);
                    pushStatus('Non riesco a leggere il file .env. Assicurati che esista e che contenga GOOGLE_MAPS_API_KEY.', true);
                }
            }

            async function readEnvFile() {
                const response = await fetch('.env', { cache: 'no-store' });
                if (!response.ok) {
                    throw new Error(`Impossibile caricare .env (HTTP ${response.status})`);
                }
                return response.text();
            }

            function parseEnv(content) {
                const result = {};
                if (!content) {
                    return result;
                }
                content.split(/\r?\n/).forEach((line) => {
                    const trimmed = line.trim();
                    if (!trimmed || trimmed.startsWith('#')) {
                        return;
                    }
                    const separatorIndex = trimmed.indexOf('=');
                    if (separatorIndex === -1) {
                        return;
                    }
                    const key = trimmed.slice(0, separatorIndex).trim();
                    const value = trimmed.slice(separatorIndex + 1).trim();
                    if (key) {
                        result[key] = value;
                    }
                });
                return result;
            }

            function ensureGoogleMapsScript(apiKey) {
                if (!apiKey) {
                    return;
                }
                const existing = document.querySelector('script[data-google-maps="true"]');
                if (existing) {
                    if (existing.dataset.key === apiKey) {
                        return;
                    }
                    existing.remove();
                }
                const encodedKey = encodeURIComponent(apiKey);
                const script = document.createElement('script');
                script.src = `https://maps.googleapis.com/maps/api/js?key=${encodedKey}&libraries=geometry&v=beta&callback=initMap`;
                script.async = true;
                script.defer = true;
                script.dataset.googleMaps = 'true';
                script.dataset.key = apiKey;
                script.addEventListener('error', () => {
                    pushStatus('Errore nel caricamento di Google Maps. Verifica la tua API key nel file .env.', true);
                });
                document.body.appendChild(script);
            }

            function initMap() {
                if (!window.google || !window.google.maps) {
                    pushStatus('Google Maps non è stato caricato. Inserisci una API key valida e ricarica la pagina.', true);
                    return;
                }
                const mapOptions = {
                    center: { lat: 48.85837, lng: 2.29448 },
                    zoom: 18,
                    heading: state.map.heading,
                    tilt: state.map.tilt,
                    mapTypeId: 'satellite',
                    disableDefaultUI: false,
                    gestureHandling: 'greedy'
                };
                if (state.config.mapId) {
                    mapOptions.mapId = state.config.mapId;
                }
                state.map.instance = new google.maps.Map(document.getElementById('map'), mapOptions);
                state.map.elevationService = new google.maps.ElevationService();

                state.map.instance.addListener('click', (event) => {
                    if (!event.latLng) {
                        return;
                    }
                    handleMapClick(event.latLng);
                });

                if (!state.config.mapId) {
                    pushStatus('Mappa pronta (2D). Per la visualizzazione 3D imposta GOOGLE_MAPS_MAP_ID nel file .env con un map ID vettoriale.', false);
                } else {
                    pushStatus('Mappa pronta. Clicca su un punto della foto e poi sulla mappa per completare la corrispondenza.', false);
                }
            }

            function handleMapClick(latLng) {
                if (!state.pending || state.pending.type !== 'map') {
                    pushStatus('Prima seleziona un punto sull’immagine da collegare.', true);
                    return;
                }
                const entry = state.correspondences.find((item) => item.id === state.pending.id);
                if (!entry) {
                    state.pending = null;
                    return;
                }

                const lat = latLng.lat();
                const lng = latLng.lng();

                if (entry.marker) {
                    entry.marker.setMap(null);
                }

                entry.mapPoint = {
                    lat,
                    lng,
                    altitude: null,
                    ecef: null
                };

                entry.marker = new google.maps.Marker({
                    position: { lat, lng },
                    label: entry.id.toString(),
                    map: state.map.instance,
                    draggable: true,
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 10,
                        strokeColor: '#0f172a',
                        strokeWeight: 2,
                        fillColor: '#38bdf8',
                        fillOpacity: 0.9
                    }
                });

                entry.marker.addListener('dragend', (dragEvent) => {
                    const newLat = dragEvent.latLng.lat();
                    const newLng = dragEvent.latLng.lng();
                    entry.mapPoint.lat = newLat;
                    entry.mapPoint.lng = newLng;
                    fetchElevation(entry, true);
                    updateTable();
                });

                fetchElevation(entry, false);

                state.pending = null;
                updateTable();
                drawOverlay();
                pushStatus(`Punto #${entry.id} collegato sulla mappa. Continua ad aggiungere corrispondenze.`);
            }

            function fetchElevation(entry, silent) {
                if (!state.map.elevationService) {
                    return;
                }
                const request = {
                    locations: [{ lat: entry.mapPoint.lat, lng: entry.mapPoint.lng }]
                };
                state.map.elevationService.getElevationForLocations(request, (results, status) => {
                    if (status === 'OK' && results && results.length > 0) {
                        entry.mapPoint.altitude = results[0].elevation;
                        entry.mapPoint.ecef = latLngAltToECEF(entry.mapPoint.lat, entry.mapPoint.lng, entry.mapPoint.altitude);
                        updateTable();
                        if (!silent) {
                            pushStatus(`Altitudine terreno stimata per il punto #${entry.id}: ${entry.mapPoint.altitude.toFixed(1)} m.`, false);
                        }
                    } else {
                        entry.mapPoint.altitude = 0;
                        entry.mapPoint.ecef = latLngAltToECEF(entry.mapPoint.lat, entry.mapPoint.lng, 0);
                        updateTable();
                        if (!silent) {
                            pushStatus(`Altitudine non disponibile per il punto #${entry.id}. Impostata a 0 m, modificabile manualmente.`, true);
                        }
                    }
                });
            }

            function adjustTilt(step) {
                if (!state.map.instance) {
                    return;
                }
                state.map.tilt = clamp(state.map.tilt + step, 0, 67.5);
                state.map.instance.setTilt(state.map.tilt);
            }

            function adjustHeading(step) {
                if (!state.map.instance) {
                    return;
                }
                state.map.heading = (state.map.heading + step + 360) % 360;
                state.map.instance.setHeading(state.map.heading);
            }

            function resetMapView() {
                if (!state.map.instance) {
                    return;
                }
                state.map.tilt = 60;
                state.map.heading = 0;
                state.map.instance.moveCamera({
                    center: state.map.instance.getCenter(),
                    zoom: state.map.instance.getZoom(),
                    heading: state.map.heading,
                    tilt: state.map.tilt
                });
            }

            function computeCameraPose() {
                if (!window.mlMatrix) {
                    pushStatus('ml-matrix non disponibile: impossibile stimare la posa.', true);
                    return;
                }
                const usable = state.correspondences.filter((entry) => entry.imagePoint && entry.mapPoint && entry.mapPoint.ecef);
                if (usable.length < 6) {
                    pushStatus('Servono almeno 6 corrispondenze complete per stimare la posa della fotocamera.', true);
                    return;
                }

                try {
                    const { Matrix, SVD } = window.mlMatrix;
                    const Adata = [];

                    usable.forEach((entry) => {
                        const { x, y } = entry.imagePoint;
                        const { x: X, y: Y, z: Z } = entry.mapPoint.ecef;
                        Adata.push([X, Y, Z, 1, 0, 0, 0, 0, -x * X, -x * Y, -x * Z, -x]);
                        Adata.push([0, 0, 0, 0, X, Y, Z, 1, -y * X, -y * Y, -y * Z, -y]);
                    });

                    const A = new Matrix(Adata);
                    const svd = new SVD(A);
                    const V = svd.rightSingularVectors;
                    const hVec = V.subMatrix(0, V.rows - 1, V.columns - 1, V.columns - 1);
                    const h = hVec.to1DArray();
                    const P = Matrix.from1DArray(3, 4, h);

                    const M = P.subMatrix(0, 2, 0, 2);
                    const p4 = P.subMatrix(0, 2, 3, 3);

                    const Minv = invert3x3(M, Matrix);
                    const cameraCenterVec = Minv.mmul(p4);
                    const cameraECEF = {
                        x: -cameraCenterVec.get(0, 0),
                        y: -cameraCenterVec.get(1, 0),
                        z: -cameraCenterVec.get(2, 0)
                    };

                    const geo = ecefToGeodetic(cameraECEF.x, cameraECEF.y, cameraECEF.z);
                    dom.resultLat.textContent = `${geo.lat.toFixed(6)}°`;
                    dom.resultLng.textContent = `${geo.lng.toFixed(6)}°`;
                    dom.resultAlt.textContent = `${geo.altitude.toFixed(2)} m`;

                    let headingDisplay = '-';
                    let tiltDisplay = '-';

                    try {
                        const { R } = decomposeKR(M, Matrix);
                        const forward = cameraForwardVector(R);
                        const { heading, tilt } = computeViewAngles(forward, cameraECEF);
                        headingDisplay = `${heading.toFixed(1)}°`;
                        tiltDisplay = `${tilt.toFixed(1)}°`;
                        if (state.map.instance) {
                            state.map.instance.moveCamera({
                                center: { lat: geo.lat, lng: geo.lng },
                                zoom: 19,
                                heading,
                                tilt: clamp(tilt, 0, 67.5)
                            });
                            state.map.heading = heading;
                            state.map.tilt = clamp(tilt, 0, 67.5);
                        }
                    } catch (orientationError) {
                        headingDisplay = 'n/d';
                        tiltDisplay = 'n/d';
                    }

                    dom.resultHeading.textContent = headingDisplay;
                    dom.resultTilt.textContent = tiltDisplay;

                    const reprojectionError = computeReprojectionError(P, usable);
                    dom.resultReproj.textContent = `${reprojectionError.toFixed(2)} px`;
                    dom.resultsCard.style.display = 'grid';

                    pushStatus('Posa stimata. Verifica i valori e rifinisci le corrispondenze se necessario.', false);
                } catch (error) {
                    console.error(error);
                    pushStatus('Errore nel calcolo della posa. Controlla che i punti siano ben distribuiti e riprova.', true);
                }
            }

            function computeReprojectionError(P, correspondences) {
                const { Matrix } = window.mlMatrix;
                let total = 0;
                let count = 0;
                correspondences.forEach((entry) => {
                    const world = entry.mapPoint.ecef;
                    const point3D = new Matrix([[world.x], [world.y], [world.z], [1]]);
                    const projected = P.mmul(point3D);
                    const w = projected.get(2, 0);
                    if (Math.abs(w) < 1e-9) {
                        return;
                    }
                    const x = projected.get(0, 0) / w;
                    const y = projected.get(1, 0) / w;
                    const dx = x - entry.imagePoint.x;
                    const dy = y - entry.imagePoint.y;
                    total += Math.hypot(dx, dy);
                    count += 1;
                });
                return count ? total / count : 0;
            }

            function decomposeKR(M, Matrix) {
                const array = M.to2DArray();
                const { upper, orthonormal } = rqDecompositionRows(array);
                const K = new Matrix(upper);
                const R = new Matrix(orthonormal);
                return { K, R };
            }

            function rqDecompositionRows(array) {
                const tolerance = 1e-9;
                const rows = array.map((row) => row.slice());

                const q3 = normalizeVector(rows[2], tolerance);
                const r33 = vectorDot(rows[2], q3);

                const proj2on3 = vectorDot(rows[1], q3);
                let u2 = vectorSubtract(rows[1], vectorScale(q3, proj2on3));
                const q2 = normalizeVector(u2, tolerance);
                const r23 = proj2on3;
                const r22 = vectorDot(rows[1], q2);

                const proj1on3 = vectorDot(rows[0], q3);
                const proj1on2 = vectorDot(rows[0], q2);
                let u1 = vectorSubtract(rows[0], vectorScale(q3, proj1on3));
                u1 = vectorSubtract(u1, vectorScale(q2, proj1on2));
                const q1 = normalizeVector(u1, tolerance);
                const r13 = proj1on3;
                const r12 = proj1on2;
                const r11 = vectorDot(rows[0], q1);

                const Q = [q1, q2, q3];
                const R = [
                    [r11, r12, r13],
                    [0, r22, r23],
                    [0, 0, r33]
                ];

                const diagSigns = [Math.sign(R[0][0]) || 1, Math.sign(R[1][1]) || 1, Math.sign(R[2][2]) || 1];
                diagSigns.forEach((sign, idx) => {
                    if (sign < 0) {
                        for (let row = 0; row < 3; row += 1) {
                            R[row][idx] *= -1;
                        }
                        for (let col = 0; col < 3; col += 1) {
                            Q[idx][col] *= -1;
                        }
                    }
                });

                if (determinant3x3(Q) < 0) {
                    for (let col = 0; col < 3; col += 1) {
                        Q[0][col] *= -1;
                    }
                    for (let row = 0; row < 3; row += 1) {
                        R[row][0] *= -1;
                    }
                }

                return { upper: R, orthonormal: Q };
            }

            function normalizeVector(vector, tolerance) {
                const norm = vectorNorm(vector);
                if (norm < tolerance) {
                    throw new Error('Matrice degenerata, impossibile calcolare la posa.');
                }
                return vectorScale(vector, 1 / norm);
            }

            function vectorDot(a, b) {
                return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
            }

            function vectorSubtract(a, b) {
                return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
            }

            function vectorScale(vector, scalar) {
                return [vector[0] * scalar, vector[1] * scalar, vector[2] * scalar];
            }

            function vectorNorm(vector) {
                return Math.hypot(vector[0], vector[1], vector[2]);
            }

            function determinant3x3(matrix) {
                const [[a, b, c], [d, e, f], [g, h, i]] = matrix;
                return a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);
            }

            function invert3x3(M, Matrix) {
                const m = M.to2DArray();
                const [[a, b, c], [d, e, f], [g, h, i]] = m;
                const det = a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);
                if (Math.abs(det) < 1e-9) {
                    throw new Error('Matrice non invertibile nella stima della posa.');
                }
                const inv = [
                    [(e * i - f * h) / det, (c * h - b * i) / det, (b * f - c * e) / det],
                    [(f * g - d * i) / det, (a * i - c * g) / det, (c * d - a * f) / det],
                    [(d * h - e * g) / det, (b * g - a * h) / det, (a * e - b * d) / det]
                ];
                return new Matrix(inv);
            }

            function cameraForwardVector(RMatrix) {
                const data = RMatrix.to2DArray();
                const forward = {
                    x: data[2][0],
                    y: data[2][1],
                    z: data[2][2]
                };
                const norm = Math.sqrt(forward.x ** 2 + forward.y ** 2 + forward.z ** 2) || 1;
                return {
                    x: forward.x / norm,
                    y: forward.y / norm,
                    z: forward.z / norm
                };
            }

            function computeViewAngles(forward, cameraECEF) {
                const geo = ecefToGeodetic(cameraECEF.x, cameraECEF.y, cameraECEF.z);
                const enu = ecefVectorToENU(forward, geo.lat, geo.lng);
                const heading = (Math.atan2(enu.east, enu.north) * 180 / Math.PI + 360) % 360;
                const horizontalNorm = Math.sqrt(enu.east ** 2 + enu.north ** 2);
                const pitch = Math.atan2(enu.up, horizontalNorm) * 180 / Math.PI;
                const tilt = clamp(90 - pitch, 0, 90);
                return { heading, tilt };
            }

            function ecefVectorToENU(vector, latDeg, lonDeg) {
                const lat = degToRad(latDeg);
                const lon = degToRad(lonDeg);
                const sinLat = Math.sin(lat);
                const cosLat = Math.cos(lat);
                const sinLon = Math.sin(lon);
                const cosLon = Math.cos(lon);

                const east = -sinLon * vector.x + cosLon * vector.y;
                const north = -sinLat * cosLon * vector.x - sinLat * sinLon * vector.y + cosLat * vector.z;
                const up = cosLat * cosLon * vector.x + cosLat * sinLon * vector.y + sinLat * vector.z;
                return { east, north, up };
            }

            function latLngAltToECEF(latDeg, lonDeg, altitudeMeters) {
                const a = 6378137.0;
                const e2 = 6.69437999014e-3;
                const lat = degToRad(latDeg);
                const lon = degToRad(lonDeg);
                const cosLat = Math.cos(lat);
                const sinLat = Math.sin(lat);
                const cosLon = Math.cos(lon);
                const sinLon = Math.sin(lon);
                const N = a / Math.sqrt(1 - e2 * sinLat * sinLat);
                const x = (N + altitudeMeters) * cosLat * cosLon;
                const y = (N + altitudeMeters) * cosLat * sinLon;
                const z = (N * (1 - e2) + altitudeMeters) * sinLat;
                return { x, y, z };
            }

            function ecefToGeodetic(x, y, z) {
                const a = 6378137.0;
                const e2 = 6.69437999014e-3;
                const b = a * Math.sqrt(1 - e2);
                const ep2 = (a * a - b * b) / (b * b);
                const p = Math.sqrt(x * x + y * y);
                let theta = Math.atan2(z * a, p * b);
                let sinTheta = Math.sin(theta);
                let cosTheta = Math.cos(theta);
                const lat = Math.atan2(z + ep2 * b * sinTheta * sinTheta * sinTheta,
                    p - e2 * a * cosTheta * cosTheta * cosTheta);
                const lon = Math.atan2(y, x);
                const sinLat = Math.sin(lat);
                const N = a / Math.sqrt(1 - e2 * sinLat * sinLat);
                const alt = p / Math.cos(lat) - N;
                return { lat: radToDeg(lat), lng: radToDeg(lon), altitude: alt };
            }

            function degToRad(value) {
                return value * Math.PI / 180;
            }

            function radToDeg(value) {
                return value * 180 / Math.PI;
            }

            function clamp(value, min, max) {
                return Math.min(Math.max(value, min), max);
            }

            document.addEventListener('DOMContentLoaded', () => {
                init();
                loadMapsApiFromEnv();
            });

            return {
                initMap,
                latLngAltToECEF
            };
        })();

        window.initMap = () => ImageLocalizatorApp.initMap();
    </script>
</body>
</html>
