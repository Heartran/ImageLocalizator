<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Localizator</title>
    <style>
        :root {
            color-scheme: dark;
            --bg: #0f172a;
            --bg-panel: #111c3a;
            --transform-bg: #1e293b;
            --transform-border: #334155;
            --bg-muted: #1e293b;
            --accent: #38bdf8;
            --warning: #f97316;
            --danger: #f43f5e;
            --text: #f8fafc;
            --text-muted: #cbd5f5;
            --border: #24345a;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: "Segoe UI", sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            padding: 1.25rem 2rem;
            background: rgba(15, 23, 42, 0.9);
            border-bottom: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
        }

        header h1 {
            margin: 0;
            font-size: 1.5rem;
            letter-spacing: 0.05em;
        }

        header p {
            margin: 0;
            color: var(--text-muted);
            max-width: 64rem;
        }

        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 1.5rem 2rem 2.5rem;
            gap: 1.5rem;
        }

        .panels {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
        }

        .panel {
            flex: 1 1 28rem;
            display: flex;
            flex-direction: column;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 1rem;
            padding: 1.25rem;
            gap: 1rem;
            box-shadow: 0 8px 30px rgba(8, 25, 60, 0.35);
        }

        .panel h2 {
            margin: 0;
            font-size: 1.1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .panel h2 span {
            font-size: 0.85rem;
            font-weight: 400;
            color: var(--text-muted);
        }

        .upload-area {
            border: 1px dashed var(--border);
            border-radius: 0.75rem;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.75rem;
            background: rgba(30, 41, 59, 0.45);
        }

        .upload-area input[type="file"] {
            display: none;
        }

        .upload-area label {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.6rem 1.4rem;
            border-radius: 999px;
            border: 1px solid rgba(56, 189, 248, 0.4);
            color: var(--accent);
            cursor: pointer;
            transition: background 0.2s ease, border-color 0.2s ease;
        }

        .upload-area label:hover {
            background: rgba(56, 189, 248, 0.1);
            border-color: var(--accent);
        }

        .image-container {
            position: relative;
            width: 100%;
            background: #0b1120;
            border-radius: 0.75rem;
            border: 1px solid var(--border);
            min-height: 22rem;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .image-container img {
            max-width: 100%;
            max-height: 32rem;
            display: none;
        }

        .image-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        .placeholder {
            color: var(--text-muted);
            text-align: center;
            padding: 2rem;
            max-width: 20rem;
            line-height: 1.5;
        }

        .map-container {
            position: relative;
            width: 100%;
            height: 32rem;
            border-radius: 0.75rem;
            border: 1px solid var(--border);
            overflow: hidden;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .map-overlay {
            position: absolute;
            inset: 0;
            background: rgba(15, 23, 42, 0.92);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
            text-align: center;
            color: var(--text);
            z-index: 2;
        }

        .map-overlay.visible {
            display: flex;
        }

        .map-overlay .overlay-card {
            max-width: 28rem;
            background: rgba(30, 41, 59, 0.9);
            border: 1px solid rgba(59, 130, 246, 0.35);
            border-radius: 0.85rem;
            padding: 1.25rem;
            display: grid;
            gap: 0.8rem;
        }

        .map-overlay .overlay-card h3 {
            margin: 0;
            font-size: 1rem;
            color: var(--accent);
        }

        .map-overlay .overlay-card p {
            margin: 0;
            font-size: 0.9rem;
            color: var(--text-muted);
            line-height: 1.5;
        }

        .map-overlay .overlay-card code {
            background: rgba(148, 163, 184, 0.15);
            border: 1px solid rgba(148, 163, 184, 0.3);
            border-radius: 0.3rem;
            padding: 0 0.35rem;
            color: var(--text);
        }

        .overlay-form {
            display: grid;
            gap: 0.85rem;
            margin-top: 0.5rem;
        }

        .overlay-field {
            display: grid;
            gap: 0.35rem;
            text-align: left;
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        .overlay-field input {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border-radius: 0.6rem;
            border: 1px solid rgba(59, 130, 246, 0.4);
            background: rgba(15, 23, 42, 0.6);
            color: var(--text);
            font-size: 0.9rem;
        }

        .overlay-field input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
        }

        .overlay-remember {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .overlay-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .overlay-actions button {
            padding: 0.6rem 1rem;
            border-radius: 0.65rem;
            border: 1px solid rgba(59, 130, 246, 0.35);
            background: rgba(56, 189, 248, 0.12);
            color: var(--accent);
            cursor: pointer;
            font-size: 0.85rem;
        }

        .overlay-actions button:hover {
            background: rgba(56, 189, 248, 0.25);
        }

        .overlay-actions .btn-primary {
            border: none;
            color: var(--text);
            background: linear-gradient(135deg, rgba(56, 189, 248, 0.85), rgba(59, 130, 246, 0.85));
        }

        .overlay-actions .btn-primary:hover {
            background: linear-gradient(135deg, rgba(56, 189, 248, 0.95), rgba(59, 130, 246, 0.95));
        }

        .link-button {
            background: transparent !important;
            border: none !important;
            color: var(--text-muted) !important;
            text-decoration: underline;
            padding-left: 0;
        }

        .overlay-error {
            margin: 0;
            font-size: 0.8rem;
            color: var(--danger);
        }

        .legend {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .legend span {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
        }

        .legend .dot {
            width: 0.75rem;
            height: 0.75rem;
            border-radius: 999px;
            display: inline-block;
        }

        .dot.image {
            background: var(--accent);
        }

        .dot.pending {
            background: var(--warning);
        }

        .controls-row {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
        }

        .controls-row button {
            border: none;
            border-radius: 0.6rem;
            padding: 0.6rem 1rem;
            background: rgba(56, 189, 248, 0.18);
            color: var(--accent);
            font-size: 0.9rem;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .controls-row button:hover {
            background: rgba(56, 189, 248, 0.3);
        }

        .badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 1.75rem;
            height: 1.75rem;
            border-radius: 0.5rem;
            background: rgba(56, 189, 248, 0.12);
            border: 1px solid rgba(56, 189, 248, 0.4);
            color: var(--accent);
            font-size: 0.85rem;
            font-weight: 600;
        }

        .data-panel {
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 1rem;
            padding: 1.25rem;
            box-shadow: 0 8px 30px rgba(8, 25, 60, 0.35);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            border: 1px solid var(--border);
            border-radius: 0.6rem;
            overflow: hidden;
        }

        thead {
            background: rgba(30, 41, 59, 0.8);
        }

        th, td {
            padding: 0.65rem 0.85rem;
            text-align: left;
            border-bottom: 1px solid rgba(36, 52, 90, 0.6);
            font-size: 0.85rem;
        }

        tbody tr:hover {
            background: rgba(56, 189, 248, 0.06);
        }

        tbody tr:last-child td {
            border-bottom: none;
        }

        .pending-map {
            background: rgba(249, 115, 22, 0.15) !important;
        }

        .table-actions button {
            padding: 0.35rem 0.6rem;
            border-radius: 0.5rem;
            border: 1px solid rgba(244, 63, 94, 0.4);
            background: rgba(244, 63, 94, 0.12);
            color: var(--danger);
            font-size: 0.75rem;
            cursor: pointer;
        }

        .table-actions button:hover {
            background: rgba(244, 63, 94, 0.25);
        }

        .status-banner {
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            background: rgba(56, 189, 248, 0.12);
            border: 1px solid rgba(56, 189, 248, 0.4);
            color: var(--text);
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .status-banner strong {
            color: var(--accent);
        }

        .secondary {
            color: var(--text-muted);
            font-size: 0.8rem;
        }

        .notice {
            background: rgba(249, 115, 22, 0.15);
            border: 1px solid rgba(249, 115, 22, 0.4);
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            font-size: 0.8rem;
            line-height: 1.4;
            color: #fcd34d;
        }

        input[type="number"] {
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(56, 189, 248, 0.25);
            border-radius: 0.5rem;
            padding: 0.4rem 0.6rem;
            color: var(--text);
            width: 6rem;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.2);
        }

        .btn-primary {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            border: none;
            background: linear-gradient(135deg, rgba(56, 189, 248, 0.85), rgba(59, 130, 246, 0.85));
            color: var(--text);
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            align-self: flex-start;
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 25px rgba(56, 189, 248, 0.2);
        }

        .results-card {
            display: grid;
            gap: 0.75rem;
            background: rgba(15, 23, 42, 0.9);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            padding: 1rem 1.25rem;
        }

        .results-card h3 {
            margin: 0;
            font-size: 1rem;
            color: var(--accent);
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(12rem, 1fr));
            gap: 0.85rem;
        }

        .metric {
            padding: 0.75rem;
            border-radius: 0.6rem;
            background: rgba(56, 189, 248, 0.08);
            border: 1px solid rgba(56, 189, 248, 0.2);
            display: grid;
            gap: 0.35rem;
        }

        .metric span {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .metric strong {
            font-size: 0.95rem;
            letter-spacing: 0.02em;
        }

        .empty-state {
            padding: 1rem;
            border-radius: 0.75rem;
            border: 1px dashed rgba(148, 163, 184, 0.35);
            color: var(--text-muted);
            text-align: center;
        }

        @media (max-width: 960px) {
            header {
                padding: 1.1rem 1.5rem;
            }

            main {
                padding: 1.5rem;
            }
        }

        .transform-panel {
            background: var(--transform-bg);
            border: 1px solid var(--transform-border);
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .transform-panel h3 {
            margin-top: 0;
            margin-bottom: 1rem;
            font-size: 1.1rem;
            color: var(--accent);
        }

        .transform-panel h4 {
            margin: 0.5rem 0;
            font-size: 0.9rem;
            color: #94a3b8;
        }

        .transform-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .transform-group {
            background: rgba(15, 23, 42, 0.5);
            border: 1px solid var(--transform-border);
            border-radius: 6px;
            padding: 0.75rem;
        }

        .transform-group label {
            display: block;
            margin: 0.5rem 0;
            font-size: 0.9rem;
        }

        .transform-group input[type="number"] {
            width: 60px;
            padding: 0.25rem 0.5rem;
            margin-left: 0.5rem;
            background: #0f172a;
            border: 1px solid #334155;
            border-radius: 4px;
            color: #e2e8f0;
        }

        #resetTransforms {
            width: 100%;
            margin-top: 0.5rem;
        }
    </style>
</head>
<body>
    <header>
        <h1>Image Localizator</h1>
        <p>
            Carica un'immagine, allinea punti corrispondenti fra foto e mappa satellitare 3D e calcola una posa approssimata della fotocamera.
            Configura un file <code>.env</code> con <code>GOOGLE_MAPS_API_KEY=</code> per abilitare il caricamento della mappa.
        </p>
    </header>

    <main>
        <section class="status-banner" id="statusBanner">
            <strong>Pronto:</strong>
            <span id="statusMessage">carica una foto e fai clic per iniziare a creare corrispondenze 2D ↔ 3D.</span>
        </section>

        <section class="panels">
            <div class="panel image-panel">
                <h2>Foto di riferimento <span>(2D)</span></h2>
                <div class="upload-area">
                    <label for="imageInput">Carica immagine...</label>
                    <input type="file" id="imageInput" accept="image/*">
                    <div class="notice">
                        Clicca su punti ben riconoscibili della foto. Per ognuno dovrai aggiungere il punto corrispondente sulla mappa.
                    </div>
                </div>
                <div class="legend">
                    <span><span class="dot image"></span> Punto collegato</span>
                    <span><span class="dot pending"></span> In attesa del punto mappa</span>
                </div>
                <div class="image-container" id="imageWrapper">
                    <img id="photo" alt="Foto di riferimento">
                    <canvas id="photoOverlay"></canvas>
                    <div class="placeholder" id="photoPlaceholder">
                        Carica un'immagine dell'area da localizzare. Clicca sulla foto per aggiungere i punti di riferimento.
                    </div>
                </div>
                <div class="controls-row">
                    <button id="clearImagePoints">Cancella punti foto</button>
                    <button id="fitImage">Adatta immagine</button>
                </div>
            </div>

            <div class="panel map-panel">
                <h2>Mappa satellitare <span>(3D)</span></h2>
                <div
                    class="map-container"
                    id="mapContainer"
                    data-center-lat="48.85837"
                    data-center-lng="2.29448"
                    data-zoom="18"
                    data-tilt="60"
                    data-heading="0"
                    data-tilt-step="5"
                    data-heading-step="10"
                >
                    <div id="map"></div>
                    <div class="map-overlay" id="mapOverlay">
                        <div class="overlay-card">
                            <h3>Mappa 3D non disponibile</h3>
                            <p id="overlayMessage">
                                Per utilizzare la vista 3D inserisci di seguito una API key valida e il relativo Map ID
                                oppure assicurati che siano presenti nel file <code>.env</code>.
                            </p>
                            <form id="overlayConfigForm" class="overlay-form">
                                <label class="overlay-field">
                                    <span>Google Maps API key</span>
                                    <input type="text" id="overlayApiKey" autocomplete="off" placeholder="AIza..." required>
                                </label>
                                <label class="overlay-field">
                                    <span>Google Maps Map ID</span>
                                    <input type="text" id="overlayMapId" autocomplete="off" placeholder="xxxxxxxxxxxxxxxx" required>
                                </label>
                                <label class="overlay-remember">
                                    <input type="checkbox" id="overlayRemember"> Ricorda questi valori nel browser
                                </label>
                                <div class="overlay-actions">
                                    <button type="submit" class="btn-primary">Carica mappa</button>
                                    <button type="button" id="overlayReloadEnv">Riprova lettura .env</button>
                                    <button type="button" id="overlayClearStorage" class="link-button">Dimentica dati salvati</button>
                                </div>
                                <p class="overlay-error" id="overlayError" role="alert" hidden></p>
                            </form>
                        </div>
                    </div>
                </div>
                <div class="notice">
                    Dopo aver cliccato sulla foto, posiziona qui il punto corrispondente. I marker sono trascinabili; puoi aggiornare manualmente l'altitudine in tabella.
                </div>
                <div class="controls-row">
                    <button id="tiltIncrease">Aumenta tilt</button>
                    <button id="tiltDecrease">Riduci tilt</button>
                    <button id="headingLeft">Ruota sinistra</button>
                    <button id="headingRight">Ruota destra</button>
                    <button id="resetView">Reset vista</button>
                </div>
            </div>
        </section>

        <section class="data-panel">
            <h2>Associazioni 2D ↔ 3D</h2>
            <div class="empty-state" id="emptyState">
                Servono almeno 6 corrispondenze complete per stimare la posizione della telecamera.
            </div>
            <div class="table-container">
                <table id="correspondenceTable">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Immagine (x, y)</th>
                            <th>Mappa (lat, lng, alt)</th>
                            <th>Azioni</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Le righe verranno aggiunte dinamicamente -->
                    </tbody>
                </table>
            </div>
            
            <div class="transform-panel">
                <h3>Trasformazioni Assi 3D</h3>
                <div class="transform-controls">
                    <div class="transform-group">
                        <h4>Traslazione</h4>
                        <label>X: <input type="number" id="transform-translateX" data-transform="translateX" step="0.1"></label>
                        <label>Y: <input type="number" id="transform-translateY" data-transform="translateY" step="0.1"></label>
                        <label>Z: <input type="number" id="transform-translateZ" data-transform="translateZ" step="0.1"></label>
                    </div>
                    
                    <div class="transform-group">
                        <h4>Scala</h4>
                        <label>X: <input type="number" id="transform-scaleX" data-transform="scaleX" step="0.1" value="1"></label>
                        <label>Y: <input type="number" id="transform-scaleY" data-transform="scaleY" step="0.1" value="1"></label>
                        <label>Z: <input type="number" id="transform-scaleZ" data-transform="scaleZ" step="0.1" value="1"></label>
                    </div>
                    
                    <div class="transform-group">
                        <h4>Rotazione (°)</h4>
                        <label>X: <input type="number" id="transform-rotateX" data-transform="rotateX" step="1"></label>
                        <label>Y: <input type="number" id="transform-rotateY" data-transform="rotateY" step="1"></label>
                        <label>Z: <input type="number" id="transform-rotateZ" data-transform="rotateZ" step="1"></label>
                    </div>
                </div>
                <button id="resetTransforms" class="button button-secondary">Reimposta trasformazioni</button>
            </div>
            
            <div class="button-group">
                <button id="clearPoints" class="button button-secondary">Pulisci punti</button>
                <button id="computePose" class="button button-primary" disabled>Calcola posa</button>
                <button id="exportData" class="button">Esporta dati</button>
                <button id="importData" class="button">Importa dati</button>
                <input type="file" id="importFile" accept=".json" style="display: none;">
            </div>
        </section>

        <section class="results-panel">
            <h2>Risultati stimati</h2>
            <div class="results-grid">
                <div class="metric">
                    <span>Latitudine</span>
                    <strong id="resultLat">-</strong>
                </div>
                <div class="metric">
                    <span>Longitudine</span>
                    <strong id="resultLng">-</strong>
                </div>
                <div class="metric">
                    <span>Altitudine</span>
                    <strong id="resultAlt">-</strong>
                </div>
                <div class="metric">
                    <span>Heading stimato</span>
                    <strong id="resultHeading">-</strong>
                </div>
                <div class="metric">
                    <span>Tilt stimato</span>
                    <strong id="resultTilt">-</strong>
                </div>
                <div class="metric">
                    <span>Errore medio di reproiezione</span>
                    <strong id="resultReproj">-</strong>
                </div>
            </div>
        </section>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/ml-matrix@6.10.4/matrix.umd.js" defer></script>
    <script>
        const ImageLocalizatorApp = (() => {
            'use strict';

            const STORAGE_KEYS = {
                credentials: 'image-localizator.mapsCredentials',
                mapView: 'image-localizator.mapView'
            };

            const ALTITUDE_LIMITS = {
                min: -1000,
                max: 10000
            };

            const GOOGLE_MAX_TILT = 67.5;

            const ALLOWED_IMAGE_TYPES = new Set([
                'image/jpeg',
                'image/png',
                'image/webp',
                'image/gif',
                'image/bmp',
                'image/heic',
                'image/heif'
            ]);

            const ALLOWED_IMAGE_EXTENSIONS = new Set([
                'jpg',
                'jpeg',
                'png',
                'webp',
                'gif',
                'bmp',
                'heic',
                'heif',
                'tif',
                'tiff'
            ]);

            const MAX_IMAGE_BYTES = 20 * 1024 * 1024;

            const state = {
                correspondences: [],
                nextId: 1,
                pending: null,
                image: {
                    element: null,
                    overlay: null,
                    overlayCtx: null,
                    naturalWidth: 0,
                    naturalHeight: 0,
                    objectUrl: null
                },
                map: {
                    instance: null,
                    tilt: 60,
                    heading: 0,
                    zoom: 18,
                    center: null,
                    tiltStep: 5,
                    headingStep: 10,
                    viewDefaults: null,
                    preferredView: null,
                    elevationService: null
                },
                config: {
                    envLoaded: false,
                    mapsKey: null,
                    mapId: null,
                    storageAvailable: false,
                    rememberCredentials: false
                }
            };

            const dom = {};

            function cacheDom() {
                dom.imageInput = document.getElementById('imageInput');
                dom.imageWrapper = document.getElementById('imageWrapper');
                dom.photo = document.getElementById('photo');
                dom.overlay = document.getElementById('photoOverlay');
                dom.placeholder = document.getElementById('photoPlaceholder');
                dom.clearImagePoints = document.getElementById('clearImagePoints');
                dom.fitImage = document.getElementById('fitImage');
                dom.statusBanner = document.getElementById('statusBanner');
                dom.statusMessage = document.getElementById('statusMessage');
                dom.matchesTable = document.getElementById('matchesTable');
                dom.matchesBody = document.getElementById('matchesBody');
                dom.emptyState = document.getElementById('emptyState');
                dom.solveButton = document.getElementById('solveButton');
                dom.resultsCard = document.getElementById('resultsCard');
                dom.resultLat = document.getElementById('resultLat');
                dom.resultLng = document.getElementById('resultLng');
                dom.resultAlt = document.getElementById('resultAlt');
                dom.resultHeading = document.getElementById('resultHeading');
                dom.resultTilt = document.getElementById('resultTilt');
                dom.resultReproj = document.getElementById('resultReproj');
                dom.tiltIncrease = document.getElementById('tiltIncrease');
                dom.tiltDecrease = document.getElementById('tiltDecrease');
                dom.headingLeft = document.getElementById('headingLeft');
                dom.headingRight = document.getElementById('headingRight');
                dom.resetView = document.getElementById('resetView');
                dom.mapContainer = document.getElementById('mapContainer');
                dom.mapOverlay = document.getElementById('mapOverlay');
                dom.overlayForm = document.getElementById('overlayConfigForm');
                dom.overlayApiKey = document.getElementById('overlayApiKey');
                dom.overlayMapId = document.getElementById('overlayMapId');
                dom.overlayRemember = document.getElementById('overlayRemember');
                dom.overlayReloadEnv = document.getElementById('overlayReloadEnv');
                dom.overlayClearStorage = document.getElementById('overlayClearStorage');
                dom.overlayError = document.getElementById('overlayError');
                dom.overlayMessage = document.getElementById('overlayMessage');
            }

            function initializeStorage() {
                try {
                    const testKey = '__image_localizator__';
                    localStorage.setItem(testKey, '1');
                    localStorage.removeItem(testKey);
                    state.config.storageAvailable = true;
                } catch (error) {
                    state.config.storageAvailable = false;
                }
            }

            function setupOverlayHandlers() {
                if (!dom.overlayForm) {
                    return;
                }
                dom.overlayForm.addEventListener('submit', handleOverlaySubmit);
                if (dom.overlayReloadEnv) {
                    dom.overlayReloadEnv.addEventListener('click', () => loadMapsApiFromEnv(true));
                }
                if (dom.overlayClearStorage) {
                    dom.overlayClearStorage.addEventListener('click', handleOverlayClearStorage);
                }
                if (dom.overlayRemember) {
                    dom.overlayRemember.addEventListener('change', (event) => {
                        state.config.rememberCredentials = event.target.checked;
                        if (!state.config.rememberCredentials) {
                            clearStoredCredentials();
                        } else if (state.config.mapsKey && state.config.mapId) {
                            persistCredentials();
                        }
                    });
                }
            }

            function hydrateConfigurationFromStorage() {
                if (!state.config.storageAvailable) {
                    return;
                }
                try {
                    const storedCredentials = localStorage.getItem(STORAGE_KEYS.credentials);
                    if (storedCredentials) {
                        const parsed = JSON.parse(storedCredentials);
                        if (parsed && typeof parsed === 'object') {
                            if (typeof parsed.mapsKey === 'string') {
                                state.config.mapsKey = parsed.mapsKey;
                            }
                            if (typeof parsed.mapId === 'string') {
                                state.config.mapId = parsed.mapId;
                            }
                            state.config.rememberCredentials = Boolean(parsed.remember);
                        }
                    }
                } catch (error) {
                    console.warn('Impossibile leggere le credenziali salvate:', error);
                }

                try {
                    const storedView = localStorage.getItem(STORAGE_KEYS.mapView);
                    if (storedView) {
                        const parsedView = JSON.parse(storedView);
                        if (isValidStoredView(parsedView)) {
                            state.map.preferredView = parsedView;
                            state.map.center = { lat: parsedView.center.lat, lng: parsedView.center.lng };
                            state.map.zoom = parsedView.zoom;
                            state.map.tilt = parsedView.tilt;
                            state.map.heading = parsedView.heading;
                        }
                    }
                } catch (error) {
                    console.warn('Impossibile leggere le preferenze della vista:', error);
                }
            }

            function syncOverlayForm() {
                if (!dom.overlayForm) {
                    return;
                }
                if (dom.overlayApiKey) {
                    dom.overlayApiKey.value = state.config.mapsKey ?? '';
                }
                if (dom.overlayMapId) {
                    dom.overlayMapId.value = state.config.mapId ?? '';
                }
                if (dom.overlayRemember) {
                    dom.overlayRemember.checked = state.config.rememberCredentials;
                    dom.overlayRemember.disabled = !state.config.storageAvailable;
                }
                if (dom.overlayClearStorage) {
                    dom.overlayClearStorage.disabled = !state.config.storageAvailable;
                }
                clearOverlayError();
            }

            function initializeMapConfiguration() {
                const container = dom.mapContainer;
                const defaults = {
                    center: {
                        lat: parseNumber(container?.dataset.centerLat, 48.85837),
                        lng: parseNumber(container?.dataset.centerLng, 2.29448)
                    },
                    zoom: parseNumber(container?.dataset.zoom, 18),
                    tilt: parseNumber(container?.dataset.tilt, 60),
                    heading: parseNumber(container?.dataset.heading, 0),
                    tiltStep: parseNumber(container?.dataset.tiltStep, 5),
                    headingStep: parseNumber(container?.dataset.headingStep, 10)
                };

                state.map.viewDefaults = defaults;
                state.map.center = { ...defaults.center };
                state.map.zoom = defaults.zoom;
                state.map.tilt = defaults.tilt;
                state.map.heading = defaults.heading;
                state.map.tiltStep = defaults.tiltStep;
                state.map.headingStep = defaults.headingStep;
                if (!state.map.preferredView) {
                    state.map.preferredView = {
                        center: { ...defaults.center },
                        zoom: defaults.zoom,
                        tilt: defaults.tilt,
                        heading: defaults.heading
                    };
                }
            }

            function handleOverlaySubmit(event) {
                event.preventDefault();
                if (!dom.overlayApiKey || !dom.overlayMapId) {
                    return;
                }
                clearOverlayError();
                const apiKey = dom.overlayApiKey.value.trim();
                const mapId = dom.overlayMapId.value.trim();
                if (!apiKey) {
                    showOverlayError('Inserisci una Google Maps API key valida.');
                    dom.overlayApiKey.focus();
                    return;
                }
                if (!mapId) {
                    showOverlayError('Inserisci un Map ID vettoriale valido.');
                    dom.overlayMapId.focus();
                    return;
                }

                state.config.mapsKey = apiKey;
                state.config.mapId = mapId;
                state.config.rememberCredentials = Boolean(dom.overlayRemember?.checked);
                if (state.config.rememberCredentials) {
                    persistCredentials();
                } else {
                    clearStoredCredentials();
                }

                syncOverlayForm();
                hideMapOverlay();
                pushStatus('Credenziali caricate manualmente. Caricamento della mappa in corso...', false);
                ensureGoogleMapsScript(apiKey);
            }

            function handleOverlayClearStorage() {
                if (!state.config.storageAvailable) {
                    showOverlayError('Il salvataggio locale non è disponibile in questa sessione.');
                    return;
                }
                clearStoredCredentials();
                clearStoredViewPreferences();
                state.config.mapsKey = null;
                state.config.mapId = null;
                state.config.rememberCredentials = false;
                syncOverlayForm();
                pushStatus('Dati salvati rimossi dal browser.', false);
            }

            function persistCredentials() {
                if (!state.config.storageAvailable) {
                    return;
                }
                try {
                    const payload = {
                        mapsKey: state.config.mapsKey,
                        mapId: state.config.mapId,
                        remember: true
                    };
                    localStorage.setItem(STORAGE_KEYS.credentials, JSON.stringify(payload));
                } catch (error) {
                    console.warn('Impossibile salvare le credenziali:', error);
                }
            }

            function clearStoredCredentials() {
                if (!state.config.storageAvailable) {
                    return;
                }
                try {
                    localStorage.removeItem(STORAGE_KEYS.credentials);
                } catch (error) {
                    console.warn('Impossibile cancellare le credenziali salvate:', error);
                }
            }

            function persistMapView() {
                if (!state.config.storageAvailable) {
                    return;
                }
                if (!state.map.center) {
                    return;
                }
                try {
                    const payload = {
                        center: { lat: state.map.center.lat, lng: state.map.center.lng },
                        zoom: state.map.zoom,
                        tilt: state.map.tilt,
                        heading: state.map.heading
                    };
                    localStorage.setItem(STORAGE_KEYS.mapView, JSON.stringify(payload));
                    state.map.preferredView = {
                        center: { ...payload.center },
                        zoom: payload.zoom,
                        tilt: payload.tilt,
                        heading: payload.heading
                    };
                } catch (error) {
                    console.warn('Impossibile salvare la vista della mappa:', error);
                }
            }

            function clearStoredViewPreferences() {
                if (!state.config.storageAvailable) {
                    return;
                }
                try {
                    localStorage.removeItem(STORAGE_KEYS.mapView);
                } catch (error) {
                    console.warn('Impossibile rimuovere le preferenze della vista:', error);
                }
                state.map.preferredView = {
                    center: { ...state.map.viewDefaults.center },
                    zoom: state.map.viewDefaults.zoom,
                    tilt: state.map.viewDefaults.tilt,
                    heading: state.map.viewDefaults.heading
                };
            }

            function showOverlayError(message) {
                if (dom.overlayError) {
                    dom.overlayError.textContent = message;
                    dom.overlayError.hidden = false;
                }
            }

            function clearOverlayError() {
                if (dom.overlayError) {
                    dom.overlayError.textContent = '';
                    dom.overlayError.hidden = true;
                }
            }

            function isValidStoredView(view) {
                if (!view || typeof view !== 'object') {
                    return false;
                }
                const centerValid = view.center && Number.isFinite(view.center.lat) && Number.isFinite(view.center.lng);
                return (
                    centerValid &&
                    Number.isFinite(view.zoom) &&
                    Number.isFinite(view.tilt) &&
                    Number.isFinite(view.heading)
                );
            }

            function updateMapStateFromInstance() {
                if (!state.map.instance) {
                    return;
                }
                const center = state.map.instance.getCenter?.();
                if (center) {
                    state.map.center = { lat: center.lat(), lng: center.lng() };
                }
                const zoom = state.map.instance.getZoom?.();
                if (Number.isFinite(zoom)) {
                    state.map.zoom = zoom;
                }
                const heading = state.map.instance.getHeading?.();
                if (Number.isFinite(heading)) {
                    state.map.heading = heading;
                }
                const tilt = state.map.instance.getTilt?.();
                if (Number.isFinite(tilt)) {
                    state.map.tilt = tilt;
                }
            }

            function parseNumber(value, fallback) {
                const parsed = Number(value);
                return Number.isFinite(parsed) ? parsed : fallback;
            }

            function init() {
                if (!window.mlMatrix) {
                    pushStatus('Impossibile caricare la libreria ml-matrix. Controlla la connessione e ricarica.', true);
                    return;
                }

                cacheDom();
                initializeStorage();
                initializeMapConfiguration();
                setupOverlayHandlers();
                hydrateConfigurationFromStorage();
                syncOverlayForm();

                state.image.element = dom.photo;
                state.image.overlay = dom.overlay;
                state.image.overlayCtx = dom.overlay.getContext('2d');

                dom.imageInput.addEventListener('change', handleImageSelection);
                dom.imageWrapper.addEventListener('click', handleImageClick);
                dom.clearImagePoints.addEventListener('click', clearImagePoints);
                dom.fitImage.addEventListener('click', () => fitImageToContainer(true));
                dom.matchesBody.addEventListener('click', handleTableClick);
                dom.matchesBody.addEventListener('change', handleTableChange);
                dom.solveButton.addEventListener('click', computeCameraPose);
                dom.tiltIncrease.addEventListener('click', () => adjustTilt(state.map.tiltStep));
                dom.tiltDecrease.addEventListener('click', () => adjustTilt(-state.map.tiltStep));
                dom.headingLeft.addEventListener('click', () => adjustHeading(-state.map.headingStep));
                dom.headingRight.addEventListener('click', () => adjustHeading(state.map.headingStep));
                dom.resetView.addEventListener('click', resetMapView);
                window.addEventListener('resize', syncOverlaySize);

                state.image.element.addEventListener('load', () => {
                    state.image.naturalWidth = state.image.element.naturalWidth;
                    state.image.naturalHeight = state.image.element.naturalHeight;
                    dom.placeholder.style.display = 'none';
                    state.image.element.style.display = 'block';
                    syncOverlaySize();
                    drawOverlay();
                    pushStatus('Immagine caricata. Clicca su un punto della foto per iniziare una corrispondenza.', false);
                });
            }

            function resetCorrespondencesState(options = {}) {
                state.correspondences.forEach((entry) => {
                    if (entry.marker) {
                        entry.marker.setMap(null);
                    }
                });
                state.correspondences = [];
                state.nextId = 1;
                state.pending = null;
                updateTable();
                drawOverlay();
                if (dom.resultsCard) {
                    dom.resultsCard.style.display = 'none';
                }
                if (options.statusMessage) {
                    pushStatus(options.statusMessage, Boolean(options.isError));
                }
            }

            function releaseImageObjectUrl() {
                if (state.image.objectUrl) {
                    try {
                        URL.revokeObjectURL(state.image.objectUrl);
                    } catch (error) {
                        console.warn('Impossibile rilasciare l\'URL dell\'immagine:', error);
                    }
                    state.image.objectUrl = null;
                }
            }

            function isSupportedImageFile(file) {
                if (!file) {
                    return false;
                }
                if (file.type && ALLOWED_IMAGE_TYPES.has(file.type.toLowerCase())) {
                    return true;
                }
                const name = file.name || '';
                const dotIndex = name.lastIndexOf('.');
                if (dotIndex !== -1) {
                    const ext = name.slice(dotIndex + 1).toLowerCase();
                    if (ALLOWED_IMAGE_EXTENSIONS.has(ext)) {
                        return true;
                    }
                }
                return false;
            }

            function handleImageSelection(event) {
                const file = event.target.files?.[0];
                if (!file) {
                    return;
                }
                if (file.size > MAX_IMAGE_BYTES) {
                    pushStatus('Il file selezionato supera i 20 MB consentiti.', true);
                    event.target.value = '';
                    return;
                }
                if (!isSupportedImageFile(file)) {
                    pushStatus('Formato immagine non supportato. Utilizza JPEG, PNG, WebP o formati standard.', true);
                    event.target.value = '';
                    return;
                }
                try {
                    const url = URL.createObjectURL(file);
                    releaseImageObjectUrl();
                    state.image.objectUrl = url;
                    state.image.element.src = url;
                    resetCorrespondencesState();
                } catch (error) {
                    console.error('Errore nel caricamento dell\'immagine:', error);
                    pushStatus('Impossibile caricare l\'immagine selezionata. Riprovare con un file differente.', true);
                }
            }

            function handleImageClick(event) {
                if (!state.image.naturalWidth || !state.image.naturalHeight) {
                    return;
                }
                const rect = state.image.element.getBoundingClientRect();
                if (event.clientX < rect.left || event.clientX > rect.right || event.clientY < rect.top || event.clientY > rect.bottom) {
                    return;
                }

                const relativeX = (event.clientX - rect.left) / rect.width;
                const relativeY = (event.clientY - rect.top) / rect.height;

                const xPx = relativeX * state.image.naturalWidth;
                const yPx = relativeY * state.image.naturalHeight;

                const id = state.nextId++;
                const entry = {
                    id,
                    imagePoint: { x: xPx, y: yPx },
                    mapPoint: null,
                    marker: null
                };
                state.correspondences.push(entry);
                state.pending = { type: 'map', id };
                updateTable();
                drawOverlay();
                highlightPending(entry.id);
                pushStatus(`Punto #${id} aggiunto sulla foto. Ora clicca sulla mappa per posizionare la corrispondenza.`, false);
            }

            function highlightPending(id) {
                if (!dom.matchesBody) {
                    return;
                }
                dom.matchesBody.querySelectorAll('tr').forEach((row) => {
                    if (Number(row.dataset.id) === id) {
                        row.classList.add('pending-map');
                    } else {
                        row.classList.remove('pending-map');
                    }
                });
            }

            function clearImagePoints() {
                resetCorrespondencesState({ statusMessage: 'Tutti i punti sono stati rimossi.', isError: false });
            }

            function fitImageToContainer(notify = false) {
                if (!state.image.naturalWidth) {
                    return;
                }
                state.image.element.style.width = '100%';
                state.image.element.style.height = 'auto';
                syncOverlaySize();
                drawOverlay();
                if (notify) {
                    pushStatus('Immagine adattata al contenitore.', false);
                }
            }

            function syncOverlaySize() {
                if (!state.image.naturalWidth) {
                    return;
                }
                const rect = state.image.element.getBoundingClientRect();
                state.image.overlay.width = rect.width;
                state.image.overlay.height = rect.height;
                state.image.overlay.style.width = `${rect.width}px`;
                state.image.overlay.style.height = `${rect.height}px`;
                drawOverlay();
            }

            function drawOverlay() {
                const ctx = state.image.overlayCtx;
                if (!ctx) {
                    return;
                }
                const width = state.image.overlay.width;
                const height = state.image.overlay.height;
                ctx.clearRect(0, 0, width, height);
                ctx.lineWidth = 2;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                state.correspondences.forEach((entry) => {
                    if (!entry.imagePoint) {
                        return;
                    }
                    const { x, y } = toDisplayCoordinates(entry.imagePoint);
                    const isPending = state.pending?.id === entry.id && state.pending?.type === 'map';
                    ctx.fillStyle = isPending ? '#f97316' : '#38bdf8';
                    ctx.strokeStyle = 'rgba(15, 23, 42, 0.65)';
                    ctx.beginPath();
                    ctx.arc(x, y, 7, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    ctx.fillStyle = '#0b1120';
                    ctx.font = '600 11px "Segoe UI", sans-serif';
                    ctx.fillText(entry.id.toString(), x, y + 0.5);
                });
            }

            function toDisplayCoordinates(point) {
                const rect = state.image.element.getBoundingClientRect();
                const scaleX = rect.width / state.image.naturalWidth;
                const scaleY = rect.height / state.image.naturalHeight;
                return {
                    x: point.x * scaleX,
                    y: point.y * scaleY
                };
            }

            function updateTable() {
                if (!dom.matchesBody || !dom.matchesTable || !dom.emptyState) {
                    return;
                }

                if (!state.correspondences.length) {
                    dom.matchesTable.style.display = 'none';
                    dom.emptyState.style.display = 'block';
                    dom.matchesBody.textContent = '';
                    return;
                }

                dom.matchesTable.style.display = 'table';
                dom.emptyState.style.display = 'none';

                const existingRows = new Map(Array.from(dom.matchesBody.children).map((row) => [Number(row.dataset.id), row]));
                const fragment = document.createDocumentFragment();

                state.correspondences.forEach((entry) => {
                    let row = existingRows.get(entry.id);
                    if (!row) {
                        row = document.createElement('tr');
                    }
                    renderCorrespondenceRow(row, entry);
                    fragment.appendChild(row);
                    existingRows.delete(entry.id);
                });

                existingRows.forEach((row) => row.remove());
                dom.matchesBody.replaceChildren(fragment);

                if (state.pending?.type === 'map') {
                    highlightPending(state.pending.id);
                }
            }

            function renderCorrespondenceRow(row, entry) {
                const latLngContent = entry.mapPoint
                    ? `<div>Lat: ${entry.mapPoint.lat.toFixed(6)}</div><div>Lng: ${entry.mapPoint.lng.toFixed(6)}</div>`
                    : '<div class="secondary">Clicca sulla mappa</div>';

                const altitudeValue = entry.mapPoint?.altitude != null
                    ? entry.mapPoint.altitude.toFixed(2)
                    : '';

                row.dataset.id = entry.id.toString();
                row.innerHTML = `
                    <td><span class="badge">${entry.id}</span></td>
                    <td>${entry.imagePoint.x.toFixed(1)}, ${entry.imagePoint.y.toFixed(1)}</td>
                    <td>${latLngContent}</td>
                    <td><input type="number" class="altitude-input" data-id="${entry.id}" value="${altitudeValue}" step="0.1" placeholder="Alt"></td>
                    <td class="table-actions"><button data-action="remove" data-id="${entry.id}">Rimuovi</button></td>
                `;

                const input = row.querySelector('input.altitude-input');
                if (input) {
                    input.dataset.previousValue = altitudeValue;
                }
            }

            function handleTableClick(event) {
                const target = event.target;
                if (!(target instanceof HTMLElement)) {
                    return;
                }
                if (target.dataset.action === 'remove') {
                    const id = Number(target.dataset.id);
                    removeCorrespondence(id);
                }
            }

            function handleTableChange(event) {
                const target = event.target;
                if (!(target instanceof HTMLInputElement)) {
                    return;
                }
                if (target.classList.contains('altitude-input')) {
                    const id = Number(target.dataset.id);
                    const rawValue = target.value.trim();
                    const previousValue = target.dataset.previousValue ?? '';
                    if (rawValue === '') {
                        const entryToClear = state.correspondences.find((item) => item.id === id);
                        if (entryToClear && entryToClear.mapPoint) {
                            entryToClear.mapPoint.altitude = null;
                            entryToClear.mapPoint.ecef = null;
                        }
                        target.dataset.previousValue = '';
                        return;
                    }
                    const value = Number(rawValue);
                    if (!Number.isFinite(value)) {
                        target.value = previousValue;
                        return;
                    }
                    if (value < ALTITUDE_LIMITS.min || value > ALTITUDE_LIMITS.max) {
                        pushStatus(`L'altitudine deve essere compresa tra ${ALTITUDE_LIMITS.min} m e ${ALTITUDE_LIMITS.max} m.`, true);
                        target.value = previousValue;
                        return;
                    }
                    const entry = state.correspondences.find((item) => item.id === id);
                    if (entry && entry.mapPoint) {
                        entry.mapPoint.altitude = value;
                        entry.mapPoint.ecef = latLngAltToECEF(entry.mapPoint.lat, entry.mapPoint.lng, value);
                        target.dataset.previousValue = value.toFixed(2);
                    } else {
                        target.value = previousValue;
                    }
                }
            }

            function removeCorrespondence(id) {
                const index = state.correspondences.findIndex((entry) => entry.id === id);
                if (index === -1) {
                    return;
                }
                const [removed] = state.correspondences.splice(index, 1);
                if (removed?.marker) {
                    removed.marker.setMap(null);
                }
                if (state.pending?.id === id) {
                    state.pending = null;
                }
                updateTable();
                drawOverlay();
                pushStatus(`Corrispondenza #${id} rimossa.`, false);
            }

            function pushStatus(message, isError = false) {
                if (!dom.statusBanner || !dom.statusMessage) {
                    try {
                        cacheDom();
                    } catch (error) {
                        console.warn('UI non ancora pronto per aggiornare lo stato:', message);
                        return;
                    }
                }
                if (!dom.statusBanner || !dom.statusMessage) {
                    console.warn('UI non ancora pronto per aggiornare lo stato:', message);
                    return;
                }
                dom.statusBanner.style.background = isError
                    ? 'rgba(244, 63, 94, 0.18)'
                    : 'rgba(56, 189, 248, 0.12)';
                dom.statusBanner.style.borderColor = isError
                    ? 'rgba(244, 63, 94, 0.4)'
                    : 'rgba(56, 189, 248, 0.4)';
                dom.statusMessage.textContent = message;
            }

            function showMapOverlay(options = {}) {
                if (!dom.mapOverlay) {
                    try {
                        cacheDom();
                    } catch (error) {
                        return;
                    }
                }
                if (!dom.mapOverlay) {
                    return;
                }

                const config = typeof options === 'string' ? { message: options } : options;
                if (config.message && dom.overlayMessage) {
                    dom.overlayMessage.innerHTML = config.message;
                }
                if (config.error) {
                    showOverlayError(config.error);
                } else {
                    clearOverlayError();
                }
                if (config.prefill !== false) {
                    syncOverlayForm();
                }
                dom.mapOverlay.classList.add('visible');
                if (config.focus === 'mapId' && dom.overlayMapId) {
                    dom.overlayMapId.focus();
                } else if (config.focus === 'apiKey' && dom.overlayApiKey) {
                    dom.overlayApiKey.focus();
                }
            }

            function hideMapOverlay() {
                if (!dom.mapOverlay) {
                    return;
                }
                dom.mapOverlay.classList.remove('visible');
                clearOverlayError();
            }

            async function loadMapsApiFromEnv(forceReload = false) {
                if (!forceReload) {
                    if (state.config.mapsKey && state.config.mapId) {
                        ensureGoogleMapsScript(state.config.mapsKey);
                        return;
                    }
                    if (state.config.mapsKey && !state.config.mapId) {
                        pushStatus('Specifica un GOOGLE_MAPS_MAP_ID per abilitare la mappa 3D.', true);
                        showMapOverlay({
                            message: 'Abbiamo trovato una API key ma manca <code>GOOGLE_MAPS_MAP_ID</code>. Inserisci un Map ID vettoriale valido o aggiornalo nel file <code>.env</code>.',
                            focus: 'mapId'
                        });
                        return;
                    }
                    if (!state.config.mapsKey && state.config.mapId) {
                        showMapOverlay({
                            message: 'È stato rilevato un <code>GOOGLE_MAPS_MAP_ID</code> ma manca la chiave. Inseriscila qui sotto o aggiornala nel file <code>.env</code>.',
                            focus: 'apiKey'
                        });
                        return;
                    }
                }

                try {
                    const envContent = await readEnvFile();
                    const env = parseEnv(envContent);
                    const apiKeyRaw = env.GOOGLE_MAPS_API_KEY || env.GOOGLE_MAPS_KEY || '';
                    const apiKey = apiKeyRaw.trim();
                    const mapIdRaw = env.GOOGLE_MAPS_MAP_ID || env.GOOGLE_MAP_ID || '';
                    const mapId = mapIdRaw.trim();

                    if (!apiKey) {
                        pushStatus('Chiave Google Maps non trovata nel file .env. Inserisci manualmente la tua API key.', true);
                        showMapOverlay({
                            message: 'Il file <code>.env</code> è stato letto ma non contiene <code>GOOGLE_MAPS_API_KEY</code>. Inserisci manualmente la chiave o aggiornalo e riprova.',
                            focus: 'apiKey'
                        });
                        return;
                    }

                    state.config.mapsKey = apiKey;
                    if (mapId) {
                        state.config.mapId = mapId;
                    }

                    if (!state.config.mapId) {
                        pushStatus('Configura GOOGLE_MAPS_MAP_ID in .env per abilitare la mappa 3D oppure inseriscilo manualmente.', true);
                        showMapOverlay({
                            message: 'Per utilizzare la vista 3D imposta <code>GOOGLE_MAPS_MAP_ID</code> nel file <code>.env</code> oppure inserisci il valore manualmente qui sotto.',
                            focus: 'mapId'
                        });
                        return;
                    }

                    state.config.envLoaded = true;
                    if (state.config.rememberCredentials) {
                        persistCredentials();
                    }
                    syncOverlayForm();
                    hideMapOverlay();
                    pushStatus('Credenziali caricate da .env. Caricamento della mappa in corso...', false);
                    ensureGoogleMapsScript(apiKey);
                } catch (error) {
                    console.error(error);
                    pushStatus('Non riesco a leggere il file .env. Inserisci manualmente i valori richiesti.', true);
                    showMapOverlay({
                        message: 'Non riesco a leggere il file <code>.env</code>. Assicurati che sia raggiungibile dal server locale e contenga <code>GOOGLE_MAPS_API_KEY</code> e <code>GOOGLE_MAPS_MAP_ID</code>.',
                        focus: 'apiKey',
                        error: 'Lettura del file .env non riuscita.'
                    });
                }
            }

            async function readEnvFile() {
                const response = await fetch('.env', { cache: 'no-store' });
                if (!response.ok) {
                    throw new Error(`Impossibile caricare .env (HTTP ${response.status})`);
                }
                return response.text();
            }

            function parseEnv(content) {
                const result = {};
                if (!content) {
                    return result;
                }
                content.split(/\r?\n/).forEach((line) => {
                    const trimmed = line.trim();
                    if (!trimmed || trimmed.startsWith('#')) {
                        return;
                    }
                    const separatorIndex = trimmed.indexOf('=');
                    if (separatorIndex === -1) {
                        return;
                    }
                    const key = trimmed.slice(0, separatorIndex).trim();
                    const value = trimmed.slice(separatorIndex + 1).trim();
                    if (key) {
                        result[key] = value;
                    }
                });
                return result;
            }

            function ensureGoogleMapsScript(apiKey) {
                if (!apiKey) {
                    return;
                }
                const existing = document.querySelector('script[data-google-maps="true"]');
                if (existing) {
                    if (existing.dataset.key === apiKey) {
                        return;
                    }
                    existing.remove();
                }
                const encodedKey = encodeURIComponent(apiKey);
                const script = document.createElement('script');
                script.src = `https://maps.googleapis.com/maps/api/js?key=${encodedKey}&libraries=geometry&v=beta&callback=initMap`;
                script.async = true;
                script.defer = true;
                script.dataset.googleMaps = 'true';
                script.dataset.key = apiKey;
                script.addEventListener('error', () => {
                    pushStatus('Errore nel caricamento di Google Maps. Verifica la tua API key nel file .env.', true);
                    showMapOverlay({
                        message: 'Errore nel caricamento della libreria Google Maps. Controlla che <code>GOOGLE_MAPS_API_KEY</code> e <code>GOOGLE_MAPS_MAP_ID</code> siano corretti e che il server sia avviato tramite <code>python -m http.server</code>.',
                        error: 'Impossibile scaricare le API Google Maps.',
                        focus: 'apiKey'
                    });
                });
                document.body.appendChild(script);
            }

            function initMap() {
                if (!window.google || !window.google.maps) {
                    pushStatus('Google Maps non è stato caricato. Inserisci una API key valida e ricarica la pagina.', true);
                    showMapOverlay({ focus: 'apiKey' });
                    return;
                }
                const initialView = state.map.preferredView || state.map.viewDefaults;
                if (initialView) {
                    state.map.center = { lat: initialView.center.lat, lng: initialView.center.lng };
                    state.map.zoom = initialView.zoom;
                    state.map.tilt = clamp(initialView.tilt, 0, GOOGLE_MAX_TILT);
                    state.map.heading = initialView.heading;
                }

                const mapOptions = {
                    center: state.map.center || { lat: 48.85837, lng: 2.29448 },
                    zoom: state.map.zoom ?? 18,
                    heading: state.map.heading ?? 0,
                    tilt: state.map.tilt ?? 60,
                    mapTypeId: 'satellite',
                    disableDefaultUI: false,
                    gestureHandling: 'greedy'
                };
                if (state.config.mapId) {
                    mapOptions.mapId = state.config.mapId;
                }
                state.map.instance = new google.maps.Map(document.getElementById('map'), mapOptions);
                state.map.elevationService = new google.maps.ElevationService();
                hideMapOverlay();

                state.map.instance.addListener('click', (event) => {
                    if (!event.latLng) {
                        return;
                    }
                    handleMapClick(event.latLng);
                });

                state.map.instance.addListener('idle', () => {
                    updateMapStateFromInstance();
                    persistMapView();
                });

                updateMapStateFromInstance();
                persistMapView();

                pushStatus('Mappa 3D pronta. Clicca su un punto della foto e poi sulla mappa per completare la corrispondenza.', false);
            }

            function handleMapClick(latLng) {
                if (!state.pending || state.pending.type !== 'map') {
                    pushStatus('Prima seleziona un punto sull’immagine da collegare.', true);
                    return;
                }
                const entry = state.correspondences.find((item) => item.id === state.pending.id);
                if (!entry) {
                    state.pending = null;
                    return;
                }

                const lat = latLng.lat();
                const lng = latLng.lng();

                if (entry.marker) {
                    entry.marker.setMap(null);
                }

                entry.mapPoint = {
                    lat,
                    lng,
                    altitude: null,
                    ecef: null
                };

                entry.marker = new google.maps.Marker({
                    position: { lat, lng },
                    label: entry.id.toString(),
                    map: state.map.instance,
                    draggable: true,
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 10,
                        strokeColor: '#0f172a',
                        strokeWeight: 2,
                        fillColor: '#38bdf8',
                        fillOpacity: 0.9
                    }
                });

                entry.marker.addListener('dragend', (dragEvent) => {
                    const newLat = dragEvent.latLng.lat();
                    const newLng = dragEvent.latLng.lng();
                    entry.mapPoint.lat = newLat;
                    entry.mapPoint.lng = newLng;
                    fetchElevation(entry, true);
                    updateTable();
                });

                fetchElevation(entry, false);

                state.pending = null;
                updateTable();
                drawOverlay();
                pushStatus(`Punto #${entry.id} collegato sulla mappa. Continua ad aggiungere corrispondenze.`);
            }

            function fetchElevation(entry, silent) {
                if (!state.map.elevationService) {
                    return;
                }
                const request = {
                    locations: [{ lat: entry.mapPoint.lat, lng: entry.mapPoint.lng }]
                };
                state.map.elevationService.getElevationForLocations(request, (results, status) => {
                    if (status === 'OK' && results && results.length > 0) {
                        entry.mapPoint.altitude = results[0].elevation;
                        entry.mapPoint.ecef = latLngAltToECEF(entry.mapPoint.lat, entry.mapPoint.lng, entry.mapPoint.altitude);
                        updateTable();
                        if (!silent) {
                            pushStatus(`Altitudine terreno stimata per il punto #${entry.id}: ${entry.mapPoint.altitude.toFixed(1)} m.`, false);
                        }
                    } else {
                        entry.mapPoint.altitude = 0;
                        entry.mapPoint.ecef = latLngAltToECEF(entry.mapPoint.lat, entry.mapPoint.lng, 0);
                        updateTable();
                        if (!silent) {
                            pushStatus(`Altitudine non disponibile per il punto #${entry.id}. Impostata a 0 m, modificabile manualmente.`, true);
                        }
                    }
                });
            }

            function adjustTilt(step) {
                if (!state.map.instance) {
                    return;
                }
                state.map.tilt = clamp((state.map.tilt ?? 0) + step, 0, GOOGLE_MAX_TILT);
                state.map.instance.setTilt(state.map.tilt);
                persistMapView();
            }

            function adjustHeading(step) {
                if (!state.map.instance) {
                    return;
                }
                state.map.heading = ((state.map.heading ?? 0) + step + 360) % 360;
                state.map.instance.setHeading(state.map.heading);
                persistMapView();
            }

            function resetMapView() {
                if (!state.map.instance) {
                    return;
                }
                const target = state.map.viewDefaults || state.map.preferredView;
                if (!target) {
                    return;
                }
                state.map.center = { lat: target.center.lat, lng: target.center.lng };
                state.map.zoom = target.zoom;
                state.map.heading = target.heading;
                state.map.tilt = clamp(target.tilt, 0, GOOGLE_MAX_TILT);
                state.map.instance.moveCamera({
                    center: state.map.center,
                    zoom: state.map.zoom,
                    heading: state.map.heading,
                    tilt: state.map.tilt
                });
                persistMapView();
            }

            function arePointsCoplanar(points, tolerance = 1e-6) {
                if (points.length < 4) return true; // Meno di 4 punti sono sempre complanari
                
                // Prendi i primi tre punti per formare un piano
                const p0 = points[0];
                const p1 = points[1];
                const p2 = points[2];
                
                // Vettori nel piano
                const v1 = {x: p1.x - p0.x, y: p1.y - p0.y, z: p1.z - p0.z};
                const v2 = {x: p2.x - p0.x, y: p2.y - p0.y, z: p2.z - p0.z};
                
                // Vettore normale al piano
                const normal = {
                    x: v1.y * v2.z - v1.z * v2.y,
                    y: v1.z * v2.x - v1.x * v2.z,
                    z: v1.x * v2.y - v1.y * v2.x
                };
                
                // Controlla se tutti gli altri punti giacciono sul piano
                for (let i = 3; i < points.length; i++) {
                    const p = points[i];
                    const v = {x: p.x - p0.x, y: p.y - p0.y, z: p.z - p0.z};
                    const dot = normal.x * v.x + normal.y * v.y + normal.z * v.z;
                    
                    if (Math.abs(dot) > tolerance) {
                        return false; // Il punto non è sul piano
                    }
                }
                
                return true; // Tutti i punti sono complanari
            }

            function computeCameraPose() {
                if (!window.mlMatrix) {
                    pushStatus('ml-matrix non disponibile: impossibile stimare la posa.', true);
                    return;
                }
                const usable = state.correspondences.filter((entry) => entry.imagePoint && entry.mapPoint && entry.mapPoint.ecef);
                if (usable.length < 6) {
                    pushStatus('Servono almeno 6 corrispondenze complete per stimare la posa della fotocamera.', true);
                    return;
                }
                
                // Controlla se i punti sono complanari
                const points3D = usable.map(entry => entry.mapPoint.ecef);
                if (arePointsCoplanar(points3D)) {
                    pushStatus('I punti selezionati sono complanari. Aggiungi punti non complanari per una stima accurata.', true);
                    return;
                }

                let projectionMatrix;
                try {
                    projectionMatrix = estimateProjectionMatrix(usable);
                } catch (error) {
                    console.error('Errore nella costruzione della matrice di proiezione:', error);
                    pushStatus(error.message || 'Impossibile costruire il sistema per la stima della posa.', true);
                    return;
                }

                const { Matrix } = window.mlMatrix;
                const M = projectionMatrix.subMatrix(0, 2, 0, 2);
                const p4 = projectionMatrix.subMatrix(0, 2, 3, 3);

                let cameraECEF;
                let geo;
                try {
                    const Minv = invert3x3(M, Matrix);
                    const cameraCenterVec = Minv.mmul(p4);
                    cameraECEF = {
                        x: -cameraCenterVec.get(0, 0),
                        y: -cameraCenterVec.get(1, 0),
                        z: -cameraCenterVec.get(2, 0)
                    };
                    geo = ecefToGeodetic(cameraECEF.x, cameraECEF.y, cameraECEF.z);
                } catch (error) {
                    console.error('Errore nel calcolo del centro della fotocamera:', error);
                    pushStatus('Impossibile ricavare il centro della fotocamera. Verifica che i punti non siano degeneri.', true);
                    return;
                }

                dom.resultLat.textContent = `${geo.lat.toFixed(6)}°`;
                dom.resultLng.textContent = `${geo.lng.toFixed(6)}°`;
                dom.resultAlt.textContent = `${geo.altitude.toFixed(2)} m`;

                let headingDisplay = '-';
                let tiltDisplay = '-';

                try {
                    const { R } = decomposeKR(M, Matrix);
                    const forward = cameraForwardVector(R);
                    const { heading, tilt } = computeViewAngles(forward, cameraECEF);
                    headingDisplay = `${heading.toFixed(1)}°`;
                    tiltDisplay = `${tilt.toFixed(1)}°`;
                    if (state.map.instance) {
                        const clampedTilt = clamp(tilt, 0, GOOGLE_MAX_TILT);
                        state.map.instance.moveCamera({
                            center: { lat: geo.lat, lng: geo.lng },
                            zoom: 19,
                            heading,
                            tilt: clampedTilt
                        });
                        state.map.heading = heading;
                        state.map.tilt = clampedTilt;
                        state.map.center = { lat: geo.lat, lng: geo.lng };
                        state.map.zoom = 19;
                        persistMapView();
                    }
                } catch (orientationError) {
                    console.warn('Impossibile calcolare orientamento camera:', orientationError);
                    headingDisplay = 'n/d';
                    tiltDisplay = 'n/d';
                }

                dom.resultHeading.textContent = headingDisplay;
                dom.resultTilt.textContent = tiltDisplay;

                const reprojectionError = computeReprojectionError(projectionMatrix, usable);
                dom.resultReproj.textContent = `${reprojectionError.toFixed(2)} px`;
                dom.resultsCard.style.display = 'grid';

                pushStatus('Posa stimata. Verifica i valori e rifinisci le corrispondenze se necessario.', false);
            }

            function estimateProjectionMatrix(correspondences) {
                const { Matrix, SVD } = window.mlMatrix;
                const system = buildProjectionSystem(correspondences);
                const A = Matrix.from1DArray(system.rows, system.cols, Array.from(system.data));
                const svd = new SVD(A);
                if (!svd || !svd.rightSingularVectors) {
                    throw new Error('Decomposizione SVD non riuscita durante la stima della posa.');
                }
                const V = svd.rightSingularVectors;
                const hVec = V.subMatrix(0, V.rows - 1, V.columns - 1, V.columns - 1);
                const h = hVec.to1DArray();
                return Matrix.from1DArray(3, 4, h);
            }

            function buildProjectionSystem(correspondences) {
                const cols = 12;
                const rows = correspondences.length * 2;
                const data = new Float64Array(rows * cols);
                let rowIndex = 0;

                correspondences.forEach((entry) => {
                    const { x, y } = entry.imagePoint;
                    const { x: X, y: Y, z: Z } = entry.mapPoint.ecef;

                    const baseRow = rowIndex * cols;
                    data[baseRow + 0] = X;
                    data[baseRow + 1] = Y;
                    data[baseRow + 2] = Z;
                    data[baseRow + 3] = 1;
                    data[baseRow + 8] = -x * X;
                    data[baseRow + 9] = -x * Y;
                    data[baseRow + 10] = -x * Z;
                    data[baseRow + 11] = -x;
                    rowIndex += 1;

                    const secondBase = rowIndex * cols;
                    data[secondBase + 4] = X;
                    data[secondBase + 5] = Y;
                    data[secondBase + 6] = Z;
                    data[secondBase + 7] = 1;
                    data[secondBase + 8] = -y * X;
                    data[secondBase + 9] = -y * Y;
                    data[secondBase + 10] = -y * Z;
                    data[secondBase + 11] = -y;
                    rowIndex += 1;
                });

                return { rows, cols, data };
            }

            function computeReprojectionError(P, correspondences) {
                const { Matrix } = window.mlMatrix;
                let total = 0;
                let count = 0;
                correspondences.forEach((entry) => {
                    const world = entry.mapPoint.ecef;
                    const point3D = new Matrix([[world.x], [world.y], [world.z], [1]]);
                    const projected = P.mmul(point3D);
                    const w = projected.get(2, 0);
                    if (Math.abs(w) < 1e-9) {
                        return;
                    }
                    const x = projected.get(0, 0) / w;
                    const y = projected.get(1, 0) / w;
                    const dx = x - entry.imagePoint.x;
                    const dy = y - entry.imagePoint.y;
                    total += Math.hypot(dx, dy);
                    count += 1;
                });
                return count ? total / count : 0;
            }

            function decomposeKR(M, Matrix) {
                const array = M.to2DArray();
                const { upper, orthonormal } = rqDecompositionRows(array);
                const K = new Matrix(upper);
                const R = new Matrix(orthonormal);
                return { K, R };
            }

            function rqDecompositionRows(array) {
                const tolerance = 1e-9;
                const rows = array.map((row) => row.slice());

                const q3 = normalizeVector(rows[2], tolerance);
                const r33 = vectorDot(rows[2], q3);

                const proj2on3 = vectorDot(rows[1], q3);
                let u2 = vectorSubtract(rows[1], vectorScale(q3, proj2on3));
                const q2 = normalizeVector(u2, tolerance);
                const r23 = proj2on3;
                const r22 = vectorDot(rows[1], q2);

                const proj1on3 = vectorDot(rows[0], q3);
                const proj1on2 = vectorDot(rows[0], q2);
                let u1 = vectorSubtract(rows[0], vectorScale(q3, proj1on3));
                u1 = vectorSubtract(u1, vectorScale(q2, proj1on2));
                const q1 = normalizeVector(u1, tolerance);
                const r13 = proj1on3;
                const r12 = proj1on2;
                const r11 = vectorDot(rows[0], q1);

                const Q = [q1, q2, q3];
                const R = [
                    [r11, r12, r13],
                    [0, r22, r23],
                    [0, 0, r33]
                ];

                const diagSigns = [Math.sign(R[0][0]) || 1, Math.sign(R[1][1]) || 1, Math.sign(R[2][2]) || 1];
                diagSigns.forEach((sign, idx) => {
                    if (sign < 0) {
                        for (let row = 0; row < 3; row += 1) {
                            R[row][idx] *= -1;
                        }
                        for (let col = 0; col < 3; col += 1) {
                            Q[idx][col] *= -1;
                        }
                    }
                });

                if (determinant3x3(Q) < 0) {
                    for (let col = 0; col < 3; col += 1) {
                        Q[0][col] *= -1;
                    }
                    for (let row = 0; row < 3; row += 1) {
                        R[row][0] *= -1;
                    }
                }

                return { upper: R, orthonormal: Q };
            }

            function normalizeVector(vector, tolerance) {
                const norm = vectorNorm(vector);
                if (norm < tolerance) {
                    throw new Error('Matrice degenerata, impossibile calcolare la posa.');
                }
                return vectorScale(vector, 1 / norm);
            }

            function vectorDot(a, b) {
                return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
            }

            function vectorSubtract(a, b) {
                return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
            }

            function vectorScale(vector, scalar) {
                return [vector[0] * scalar, vector[1] * scalar, vector[2] * scalar];
            }

            function vectorNorm(vector) {
                return Math.hypot(vector[0], vector[1], vector[2]);
            }

            function determinant3x3(matrix) {
                const [[a, b, c], [d, e, f], [g, h, i]] = matrix;
                return a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);
            }

            function invert3x3(M, Matrix) {
                const m = M.to2DArray();
                const [[a, b, c], [d, e, f], [g, h, i]] = m;
                const det = a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);
                if (Math.abs(det) < 1e-9) {
                    throw new Error('Matrice non invertibile nella stima della posa.');
                }
                const inv = [
                    [(e * i - f * h) / det, (c * h - b * i) / det, (b * f - c * e) / det],
                    [(f * g - d * i) / det, (a * i - c * g) / det, (c * d - a * f) / det],
                    [(d * h - e * g) / det, (b * g - a * h) / det, (a * e - b * d) / det]
                ];
                return new Matrix(inv);
            }

            function cameraForwardVector(RMatrix) {
                const data = RMatrix.to2DArray();
                const forward = {
                    x: data[2][0],
                    y: data[2][1],
                    z: data[2][2]
                };
                const norm = Math.sqrt(forward.x ** 2 + forward.y ** 2 + forward.z ** 2) || 1;
                return {
                    x: forward.x / norm,
                    y: forward.y / norm,
                    z: forward.z / norm
                };
            }

            function computeViewAngles(forward, cameraECEF) {
                const geo = ecefToGeodetic(cameraECEF.x, cameraECEF.y, cameraECEF.z);
                const enu = ecefVectorToENU(forward, geo.lat, geo.lng);
                const heading = (Math.atan2(enu.east, enu.north) * 180 / Math.PI + 360) % 360;
                const horizontalNorm = Math.sqrt(enu.east ** 2 + enu.north ** 2);
                const pitch = Math.atan2(enu.up, horizontalNorm) * 180 / Math.PI;
                const tilt = clamp(90 - pitch, 0, 90);
                return { heading, tilt };
            }

            function ecefVectorToENU(vector, latDeg, lonDeg) {
                const lat = degToRad(latDeg);
                const lon = degToRad(lonDeg);
                const sinLat = Math.sin(lat);
                const cosLat = Math.cos(lat);
                const sinLon = Math.sin(lon);
                const cosLon = Math.cos(lon);

                const east = -sinLon * vector.x + cosLon * vector.y;
                const north = -sinLat * cosLon * vector.x - sinLat * sinLon * vector.y + cosLat * vector.z;
                const up = cosLat * cosLon * vector.x + cosLat * sinLon * vector.y + sinLat * vector.z;
                return { east, north, up };
            }

            function latLngAltToECEF(latDeg, lonDeg, altitudeMeters) {
                const a = 6378137.0;
                const e2 = 6.69437999014e-3;
                const lat = degToRad(latDeg);
                const lon = degToRad(lonDeg);
                const cosLat = Math.cos(lat);
                const sinLat = Math.sin(lat);
                const cosLon = Math.cos(lon);
                const sinLon = Math.sin(lon);
                const N = a / Math.sqrt(1 - e2 * sinLat * sinLat);
                const x = (N + altitudeMeters) * cosLat * cosLon;
                const y = (N + altitudeMeters) * cosLat * sinLon;
                const z = (N * (1 - e2) + altitudeMeters) * sinLat;
                return { x, y, z };
            }

            function ecefToGeodetic(x, y, z) {
                const a = 6378137.0;
                const e2 = 6.69437999014e-3;
                const b = a * Math.sqrt(1 - e2);
                const ep2 = (a * a - b * b) / (b * b);
                const p = Math.sqrt(x * x + y * y);
                let theta = Math.atan2(z * a, p * b);
                let sinTheta = Math.sin(theta);
                let cosTheta = Math.cos(theta);
                const lat = Math.atan2(z + ep2 * b * sinTheta * sinTheta * sinTheta,
                    p - e2 * a * cosTheta * cosTheta * cosTheta);
                const lon = Math.atan2(y, x);
                const sinLat = Math.sin(lat);
                const N = a / Math.sqrt(1 - e2 * sinLat * sinLat);
                const alt = p / Math.cos(lat) - N;
                return { lat: radToDeg(lat), lng: radToDeg(lon), altitude: alt };
            }

            function degToRad(value) {
                return value * Math.PI / 180;
            }

            function radToDeg(value) {
                return value * 180 / Math.PI;
            }

            function clamp(value, min, max) {
                return Math.min(Math.max(value, min), max);
            }

            document.addEventListener('DOMContentLoaded', () => {
                init();
                loadMapsApiFromEnv();
            });

            return {
                initMap,
                latLngAltToECEF
            };
        })();

        window.initMap = () => ImageLocalizatorApp.initMap();
    </script>
</body>
</html>
